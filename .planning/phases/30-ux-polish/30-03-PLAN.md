---
phase: 30-ux-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/workshop/chat-panel.tsx
  - src/components/canvas/react-flow-canvas.tsx
autonomous: true
must_haves:
  truths:
    - "Chat panel auto-scrolls to the bottom when new messages arrive"
    - "Chat panel scrolls to the bottom on initial page load"
    - "Journey Map page does not create duplicate cards on load"
  artifacts:
    - path: "src/components/workshop/chat-panel.tsx"
      provides: "Chat panel with reliable auto-scroll behavior"
      contains: "scrollIntoView"
    - path: "src/components/canvas/react-flow-canvas.tsx"
      provides: "Canvas with guarded gridColumns initialization"
      contains: "gridColumns"
  key_links:
    - from: "src/components/workshop/chat-panel.tsx"
      to: "messagesEndRef"
      via: "useEffect with messages dependency triggers scrollIntoView"
      pattern: "messagesEndRef.*scrollIntoView"
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/stores/canvas-store.ts"
      via: "gridColumns initialization effect"
      pattern: "setGridColumns"
---

<objective>
Fix chat auto-scroll reliability and Journey Map duplicate card bug.

Purpose: Two behavior bugs degrade the user experience -- the chat panel doesn't reliably scroll to the bottom (especially on page load with existing messages), and the Journey Map page sometimes creates duplicate cards when loading.
Output: Chat panel reliably scrolls to bottom on load and on new messages. Journey Map page loads without duplicating canvas cards.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/workshop/chat-panel.tsx
@src/components/canvas/react-flow-canvas.tsx
@src/lib/canvas/step-canvas-config.ts
@src/providers/canvas-store-provider.tsx
@src/app/workshop/[sessionId]/step/[stepId]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix chat panel auto-scroll reliability</name>
  <files>src/components/workshop/chat-panel.tsx</files>
  <action>
Fix UX-06 (chat auto-scroll):

The current auto-scroll implementation (line 329-331) uses:
```tsx
React.useEffect(() => {
  messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
}, [messages]);
```

This has two problems:
1. **On page load with existing messages**: The scroll fires before the messages DOM elements are fully rendered, so it may not scroll far enough. The `[messages]` dependency fires once on mount with initialMessages, but the DOM might not be painted yet.
2. **During streaming**: The `messages` array reference changes on every streaming chunk but `scrollIntoView` with `behavior: 'smooth'` can queue up and lag behind rapid updates.

Fix:

1. **Split into two effects** -- one for initial mount, one for ongoing messages:

```tsx
// Scroll to bottom on initial mount (after DOM paint)
const hasScrolledOnMount = React.useRef(false);
React.useEffect(() => {
  if (!hasScrolledOnMount.current && messages.length > 0) {
    // Use requestAnimationFrame to ensure DOM is painted before scrolling
    requestAnimationFrame(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: 'instant' });
    });
    hasScrolledOnMount.current = true;
  }
}, [messages.length]);
```

2. **For ongoing messages** (new messages arriving or streaming), use a smarter scroll:
```tsx
// Auto-scroll on new messages (skip if user has scrolled up)
const scrollContainerRef = React.useRef<HTMLDivElement>(null);
const isNearBottom = React.useCallback(() => {
  const container = scrollContainerRef.current;
  if (!container) return true;
  const threshold = 150; // px from bottom
  return container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
}, []);

React.useEffect(() => {
  if (messages.length > 0 && isNearBottom()) {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }
}, [messages, isNearBottom]);
```

3. **Add ref to scroll container**: The messages area div (line 370: `<div className="flex-1 overflow-y-auto p-4">`) needs a ref:
```tsx
<div ref={scrollContainerRef} className="flex-1 overflow-y-auto p-4">
```

This approach:
- Uses `behavior: 'instant'` on mount so users don't see a scroll animation on page load
- Uses `requestAnimationFrame` to wait for DOM paint before initial scroll
- Only auto-scrolls on new messages if user is near the bottom (within 150px), respecting manual scroll position
- Uses `behavior: 'smooth'` for ongoing messages for a polished feel
  </action>
  <verify>
1. Run `npm run build` to verify no build errors
2. Navigate to a step with existing chat messages -- chat should instantly show the bottom of the conversation on page load
3. Send a new message -- chat should smooth-scroll to show the new response
4. Scroll up manually, then receive a new message -- chat should NOT auto-scroll (user is reading history)
  </verify>
  <done>
Chat panel auto-scrolls to bottom on page load (instant, no animation). New messages trigger smooth auto-scroll only when user is near bottom. Manual scroll-up position is preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix Journey Map duplicate card creation on load</name>
  <files>src/components/canvas/react-flow-canvas.tsx</files>
  <action>
Fix UX-07 (Journey Map duplicate cards):

The bug: When loading the Journey Map page (step 6), cards sometimes appear duplicated. Root cause analysis:

The `react-flow-canvas.tsx` has a `useEffect` (lines 160-170) that seeds gridColumns from step config:
```tsx
useEffect(() => {
  if (stepConfig.hasGrid && stepConfig.gridConfig && gridColumns.length === 0) {
    const initialColumns = stepConfig.gridConfig.columns.map(col => ({...}));
    setGridColumns(initialColumns);
  }
}, [stepConfig, gridColumns.length, setGridColumns]);
```

The `page.tsx` already loads `initialGridColumns` from the database and passes them to `CanvasStoreProvider`. So on first load with saved state:
1. Store initializes with saved gridColumns (from `initialGridColumns` prop)
2. But the `useEffect` fires and checks `gridColumns.length === 0`
3. If there's a render cycle where `gridColumns` hasn't propagated yet, or if the store initializes with empty `gridColumns` before the saved state applies, this effect re-seeds the default columns

The actual duplicate card issue is more likely in the chat panel's `addedMessageIds` initialization. When the page loads with existing canvas post-its AND existing messages containing CANVAS_ITEM/GRID_ITEM tags, the `hasInitializedAddedIds` effect (chat-panel.tsx lines 219-237) marks messages as "already added." But if this initialization races with the canvas store hydration, it might not detect that items are already on the canvas, causing the "Add to Whiteboard" button to appear for messages whose items are already on the canvas. If the user (or some auto-trigger) clicks it, duplicates are created.

However, looking more carefully, the bug description says "does not create duplicate cards **on load**" -- this suggests an automatic duplication, not user-initiated.

The most likely cause: The `gridColumns` initialization effect in react-flow-canvas.tsx calls `setGridColumns()` which triggers `isDirty: false` (because setGridColumns uses the non-dirty setter). But the column IDs it generates differ from the saved column IDs (they come from `stepConfig.gridConfig.columns` which has static IDs like 'awareness', 'consideration'). Meanwhile, `initialGridColumns` from the database may have different IDs (UUIDs from `addGridColumn`). When the effect overwrites the saved columns with default columns, the post-its' `cellAssignment.col` IDs no longer match, causing layout confusion or the grid overlay to render improperly.

**Fix**: Guard the gridColumns initialization effect more carefully:

```tsx
useEffect(() => {
  if (stepConfig.hasGrid && stepConfig.gridConfig && gridColumns.length === 0) {
    // Only seed default columns if the store was truly initialized empty
    // (no initialGridColumns were passed to the provider).
    // The provider already handles initial state, so this effect is only
    // for the very first visit to a grid step with no saved state.
    const initialColumns: GridColumn[] = stepConfig.gridConfig.columns.map(col => ({
      id: col.id,
      label: col.label,
      width: col.width,
    }));
    setGridColumns(initialColumns);
  }
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []); // Run ONCE on mount only, not on gridColumns.length changes
```

Change the dependency array from `[stepConfig, gridColumns.length, setGridColumns]` to `[]` (mount-only). The current dependency on `gridColumns.length` means the effect re-runs whenever gridColumns transitions through empty (e.g., during store re-initialization). By running only on mount, we ensure:
- First visit (no saved state): gridColumns starts at 0, effect seeds defaults
- Return visit (saved state): gridColumns starts populated from provider, effect sees non-zero length, skips

Also add a mount-time guard by reading the initial gridColumns from the store at mount:

```tsx
// Track whether initial gridColumns were provided (from saved state)
const hadInitialGridColumns = useRef(gridColumns.length > 0);

useEffect(() => {
  if (stepConfig.hasGrid && stepConfig.gridConfig && !hadInitialGridColumns.current && gridColumns.length === 0) {
    const initialColumns: GridColumn[] = stepConfig.gridConfig.columns.map(col => ({
      id: col.id,
      label: col.label,
      width: col.width,
    }));
    setGridColumns(initialColumns);
  }
}, [stepConfig, gridColumns.length, setGridColumns]);
```

This uses a ref to capture whether gridColumns were initially non-empty (indicating saved state), preventing the effect from ever re-seeding defaults when saved columns exist.
  </action>
  <verify>
1. Run `npm run build` to verify no build errors
2. Navigate to Journey Map step (step 6) with existing canvas cards -- page should load without creating duplicate cards
3. Navigate to Journey Map step for the first time (no saved state) -- default columns should still initialize correctly
4. Navigate away from Journey Map and back -- no duplicate columns or cards should appear
  </verify>
  <done>
Journey Map page loads without creating duplicate cards. Grid columns initialize once from saved state (if exists) or from defaults (first visit only), never overwriting saved state.
  </done>
</task>

</tasks>

<verification>
Both behavior requirements addressed:
- UX-06: Chat auto-scrolls to bottom on page load (instant) and on new messages (smooth), respects manual scroll position
- UX-07: Journey Map does not duplicate cards on load (gridColumns init guarded with mount-time ref)
</verification>

<success_criteria>
1. Chat panel shows bottom of conversation instantly on page load (no visible scroll animation)
2. New chat messages cause smooth auto-scroll to bottom when user is near bottom
3. User can scroll up in chat without being snapped back to bottom
4. Journey Map step loads without creating duplicate canvas cards
5. First-time Journey Map visit still correctly initializes default grid columns
6. No TypeScript or build errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/30-ux-polish/30-03-SUMMARY.md`
</output>
