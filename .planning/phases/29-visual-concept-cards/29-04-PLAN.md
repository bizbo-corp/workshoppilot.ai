---
phase: 29-visual-concept-cards
plan: 04
type: execute
wave: 3
depends_on: ["29-02", "29-03"]
files_modified:
  - src/components/workshop/step-container.tsx
  - src/components/workshop/concept-canvas-overlay.tsx
  - src/providers/canvas-store-provider.tsx
  - src/app/workshop/[sessionId]/step/[stepId]/page.tsx
  - src/components/workshop/output-panel.tsx
autonomous: true

must_haves:
  truths:
    - "Step 9 displays concept cards on ReactFlow canvas alongside chat panel"
    - "User can trigger AI concept generation from selected Crazy 8s sketches"
    - "Generated concept cards appear on canvas with dealing-cards layout"
    - "Concept cards persist across page refresh"
    - "Step 9 is confirmed when concept cards exist (no extraction needed)"
  artifacts:
    - path: "src/components/workshop/concept-canvas-overlay.tsx"
      provides: "Generate Concepts button overlay for Step 9 canvas"
      min_lines: 40
    - path: "src/components/workshop/step-container.tsx"
      provides: "Step 9 added to CANVAS_ENABLED_STEPS"
      contains: "concept"
    - path: "src/providers/canvas-store-provider.tsx"
      provides: "conceptCards prop in CanvasStoreProvider"
      contains: "conceptCards"
  key_links:
    - from: "src/components/workshop/concept-canvas-overlay.tsx"
      to: "src/app/api/ai/generate-concept/route.ts"
      via: "fetch POST /api/ai/generate-concept"
      pattern: "fetch.*api/ai/generate-concept"
    - from: "src/components/workshop/concept-canvas-overlay.tsx"
      to: "src/stores/canvas-store.ts"
      via: "addConceptCard action from canvas store"
      pattern: "addConceptCard"
    - from: "src/components/workshop/step-container.tsx"
      to: "src/components/canvas/canvas-wrapper.tsx"
      via: "CanvasWrapper rendered for concept step"
      pattern: "CanvasWrapper.*concept"
---

<objective>
Wire Step 9 to use the ReactFlow canvas layout with concept cards, add the "Generate Concept Cards" trigger that calls the AI endpoint and populates the canvas, and update the data flow so concept cards load from persistence.

Purpose: This is the final integration plan that makes everything work end-to-end. After this, Step 9 transforms from a text-only output panel to a canvas-first experience where AI-generated concept cards appear as interactive, editable ReactFlow nodes.

Output: Step 9 shows canvas with concept cards + chat panel. AI generation works. Concept cards persist.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-visual-concept-cards/29-RESEARCH.md
@.planning/phases/29-visual-concept-cards/29-01-SUMMARY.md
@.planning/phases/29-visual-concept-cards/29-02-SUMMARY.md
@.planning/phases/29-visual-concept-cards/29-03-SUMMARY.md

# Files being modified
@src/components/workshop/step-container.tsx
@src/providers/canvas-store-provider.tsx
@src/app/workshop/[sessionId]/step/[stepId]/page.tsx
@src/components/workshop/output-panel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create concept generation overlay and update CanvasStoreProvider</name>
  <files>
    src/components/workshop/concept-canvas-overlay.tsx
    src/providers/canvas-store-provider.tsx
  </files>
  <action>
**concept-canvas-overlay.tsx:**
Create a `'use client'` component that sits as an overlay on the Step 9 canvas, providing the "Generate Concept Cards" trigger. This follows the pattern of the "Suggest Prompts" button in Crazy 8s canvas.

```typescript
'use client';

import { useState, useCallback } from 'react';
import { Sparkles, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useCanvasStore } from '@/providers/canvas-store-provider';
import { getNextConceptCardPosition } from '@/lib/canvas/concept-card-layout';
import type { ConceptCardData } from '@/lib/canvas/concept-card-types';
```

**Props:**
```typescript
interface ConceptCanvasOverlayProps {
  workshopId: string;
  stepId: string;
}
```

**Implementation:**

1. Read `conceptCards` and `addConceptCard` from canvas store.

2. **Load selected Crazy 8s sketch data from Step 8 artifact:**
   - On mount, fetch Step 8 artifact via a server action or API call to get `selectedSketchSlotIds` and `crazy8sSlots` data. Use a `useEffect` that calls a fetch to load Step 8 data:
   ```typescript
   const [step8Data, setStep8Data] = useState<{
     selectedSlotIds: string[];
     slots: Array<{ slotId: string; title: string; imageUrl?: string }>;
   } | null>(null);
   const [isLoading, setIsLoading] = useState(true);
   ```

   Fetch from the existing loadCanvasState pattern -- but since this is a client component, use a fetch call to a new lightweight endpoint or import `loadCanvasState` as a server action. The simplest approach: directly import `loadCanvasState` from `@/actions/canvas-actions` (it's a 'use server' action, callable from client):
   ```typescript
   import { loadCanvasState } from '@/actions/canvas-actions';
   ```

   In `useEffect`:
   ```typescript
   useEffect(() => {
     async function loadStep8Data() {
       // Load Step 8 canvas state (crazy 8s slots)
       const step8Canvas = await loadCanvasState(workshopId, 'ideation');
       // Load Step 8 artifact (selectedSketchSlotIds)
       const resp = await fetch(`/api/workshop/${workshopId}/step-artifact?stepId=ideation`);
       // ... or query stepArtifacts directly
     }
     loadStep8Data();
   }, [workshopId]);
   ```

   Actually, the simplest approach: load Step 8 data from the server action. Import `loadCanvasState` for the slots, and fetch Step 8 artifact separately. BUT -- `loadCanvasState` is a server action, so it can be called from a client component directly.

   Better approach for simplicity: pass the selected slot data as props from the page or parent component. The Step 9 page loads Step 8 artifact data and passes it down. This avoids client-side fetching.

   For this plan, use the **hybrid approach**:
   - The overlay fetches Step 8 data on mount using the server action `loadCanvasState(workshopId, 'ideation')` for crazy8sSlots
   - And queries the Step 8 artifact for `selectedSketchSlotIds` via a fetch to `/api/workshop/step-artifact` (or a dedicated server action)

   **Simplest path:** Create a dedicated server action in the same file or a new one:
   ```typescript
   // At the top of concept-canvas-overlay.tsx or in a separate file
   // Use inline fetch to the extract API or a simple server action
   ```

   Actually, the SIMPLEST approach that avoids new endpoints: fetch Step 8 artifact data directly from the page.tsx (server component) and pass it through StepContainer and down to the canvas overlay as props. The page already loads artifact data.

   **Final decision for simplicity:** The overlay component receives `selectedSketchSlotIds` and `crazy8sSlots` as props from the parent (loaded server-side). If the data isn't available yet, show an informational message.

   Updated props:
   ```typescript
   interface ConceptCanvasOverlayProps {
     workshopId: string;
     stepId: string;
     selectedSketchSlotIds?: string[];
     crazy8sSlots?: Array<{ slotId: string; title: string; imageUrl?: string }>;
   }
   ```

3. **Generate button:** Only visible when `conceptCards.length === 0` (no concepts generated yet). Shows how many selected sketches will be developed. Disabled if no selectedSketchSlotIds available.

4. **Generation handler:**
   ```typescript
   const [isGenerating, setIsGenerating] = useState(false);

   const handleGenerate = useCallback(async () => {
     if (!selectedSketchSlotIds?.length || !crazy8sSlots?.length) return;
     setIsGenerating(true);

     for (const slotId of selectedSketchSlotIds) {
       const slot = crazy8sSlots.find(s => s.slotId === slotId);
       if (!slot) continue;

       try {
         const response = await fetch('/api/ai/generate-concept', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({
             workshopId,
             slotId: slot.slotId,
             crazy8sTitle: slot.title || `Sketch ${slot.slotId}`,
           }),
         });

         if (!response.ok) {
           console.error(`Failed to generate concept for ${slotId}`);
           continue;
         }

         const { concept } = await response.json();

         // Calculate position using dealing-cards layout
         const existingCards = useCanvasStore.getState?.() ...
         // Actually, read from store at call time

         addConceptCard({
           position: getNextConceptCardPosition(conceptCards),
           conceptName: concept.conceptName || 'New Concept',
           ideaSource: slot.title || `Sketch ${slot.slotId}`,
           sketchSlotId: slot.slotId,
           sketchImageUrl: slot.imageUrl,
           elevatorPitch: concept.elevatorPitch || '',
           usp: concept.usp || '',
           swot: concept.swot || { strengths: ['','',''], weaknesses: ['','',''], opportunities: ['','',''], threats: ['','',''] },
           feasibility: concept.feasibility || {
             technical: { score: 3, rationale: '' },
             business: { score: 3, rationale: '' },
             userDesirability: { score: 3, rationale: '' },
           },
           billboardHero: concept.billboardHero,
         });
       } catch (error) {
         console.error(`Failed to generate concept for ${slotId}:`, error);
       }
     }

     setIsGenerating(false);
   }, [selectedSketchSlotIds, crazy8sSlots, workshopId, addConceptCard, conceptCards]);
   ```

   NOTE: Since `conceptCards` changes as cards are added inside the loop, use a ref or read from store directly inside the loop for position calculation. The simplest fix: track a running index for offset calculation instead of reading store mid-loop:
   ```typescript
   let positionIndex = conceptCards.length;
   for (const slotId of selectedSketchSlotIds) {
     // ... generate concept ...
     const position = positionIndex === 0
       ? { x: 100, y: 100 }
       : { x: 100 + (positionIndex * 30), y: 100 + (positionIndex * 30) };
     positionIndex++;
     addConceptCard({ position, ...conceptData });
   }
   ```

5. **UI layout:**
   - Position: `absolute bottom-16 left-1/2 -translate-x-1/2 z-20` (centered at bottom, above canvas toolbar).
   - When `conceptCards.length === 0` and `selectedSketchSlotIds` available: show generate button with sketch count.
   - When `isGenerating`: show loading spinner with "Generating concepts...".
   - When `conceptCards.length > 0`: hide (concepts already exist, user can re-generate via chat or reset).
   - When no `selectedSketchSlotIds`: show info message "Complete Step 8 to generate concept cards".

**canvas-store-provider.tsx:**
1. Add import:
   ```typescript
   import type { ConceptCardData } from '@/lib/canvas/concept-card-types';
   ```
   (Also add to the existing imports from canvas-store if `ConceptCardData` is re-exported from there)

2. Add `initialConceptCards` prop to `CanvasStoreProviderProps`:
   ```typescript
   export interface CanvasStoreProviderProps {
     children: React.ReactNode;
     initialPostIts?: PostIt[];
     initialGridColumns?: GridColumn[];
     initialDrawingNodes?: DrawingNode[];
     initialConceptCards?: ConceptCardData[];  // NEW
   }
   ```

3. Destructure `initialConceptCards` in the component.

4. Pass to `createCanvasStore`:
   ```typescript
   const [store] = useState(() =>
     createCanvasStore({
       postIts: initialPostIts || [],
       gridColumns: initialGridColumns || [],
       drawingNodes: initialDrawingNodes || [],
       conceptCards: initialConceptCards || [],  // NEW
     })
   );
   ```
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors. Verify concept-canvas-overlay.tsx exports `ConceptCanvasOverlay`. Verify CanvasStoreProvider accepts `initialConceptCards` prop.
  </verify>
  <done>ConceptCanvasOverlay component renders Generate button when no concepts exist, calls AI endpoint for each selected Crazy 8s sketch, adds concept cards to canvas store with dealing-cards positioning. CanvasStoreProvider passes initial concept cards to store.</done>
</task>

<task type="auto">
  <name>Task 2: Wire Step 9 to canvas layout and update data flow</name>
  <files>
    src/components/workshop/step-container.tsx
    src/app/workshop/[sessionId]/step/[stepId]/page.tsx
    src/components/workshop/output-panel.tsx
  </files>
  <action>
**step-container.tsx:**
1. Add `'concept'` to both `CANVAS_ENABLED_STEPS` and `CANVAS_ONLY_STEPS`:
   - Wait, looking at the layout: CANVAS_ONLY_STEPS render CanvasWrapper without RightPanel. CANVAS_ENABLED_STEPS render canvas but also show the right panel.

   For Step 9, we want: chat on left + canvas on right (not output panel). So Step 9 should be in CANVAS_ENABLED_STEPS but NOT in CANVAS_ONLY_STEPS. Actually, looking at the code more carefully:

   - `CANVAS_ONLY_STEPS` = ['stakeholder-mapping', 'sense-making'] -> These show CanvasWrapper instead of RightPanel
   - `CANVAS_ENABLED_STEPS` = ['stakeholder-mapping', 'sense-making', 'persona', 'journey-mapping'] -> These skip extraction

   For steps in CANVAS_ONLY_STEPS, the right side shows CanvasWrapper. For steps in CANVAS_ENABLED_STEPS but NOT CANVAS_ONLY_STEPS (like 'persona', 'journey-mapping'), they still show RightPanel (not canvas).

   Step 9 needs canvas on the right side. So add 'concept' to BOTH arrays:
   ```typescript
   const CANVAS_ENABLED_STEPS = ['stakeholder-mapping', 'sense-making', 'persona', 'journey-mapping', 'concept'];
   const CANVAS_ONLY_STEPS = ['stakeholder-mapping', 'sense-making', 'concept'];
   ```

2. Update the canvas content detection for Step 9. Currently:
   ```typescript
   const canvasHasContent = postIts.length > 0;
   ```
   Add concept cards check:
   ```typescript
   const conceptCards = useCanvasStore((s) => s.conceptCards);
   const canvasHasContent = postIts.length > 0 || conceptCards.length > 0;
   ```
   This ensures Step 9 is "confirmed" when concept cards exist (not just post-its).

3. Import and render `ConceptCanvasOverlay` inside the canvas area for Step 9. In the sections where `CanvasWrapper` is rendered for CANVAS_ONLY_STEPS, add the overlay as a sibling:
   ```typescript
   import { ConceptCanvasOverlay } from './concept-canvas-overlay';
   ```

   In the desktop layout where `CANVAS_ONLY_STEPS` renders `CanvasWrapper`, add conditional overlay for concept step:
   ```typescript
   {step && CANVAS_ONLY_STEPS.includes(step.id) ? (
     <div className="h-full relative">
       {/* Existing collapse button ... */}
       <CanvasWrapper
         sessionId={sessionId}
         stepId={step.id}
         workshopId={workshopId}
       />
       {step.id === 'concept' && (
         <ConceptCanvasOverlay
           workshopId={workshopId}
           stepId={step.id}
           selectedSketchSlotIds={step8SelectedSlotIds}
           crazy8sSlots={step8Crazy8sSlots}
         />
       )}
     </div>
   ) : ( ... )}
   ```

   The `step8SelectedSlotIds` and `step8Crazy8sSlots` props need to come from somewhere. The simplest approach: add them to StepContainerProps and pass from page.tsx.

4. Add new props to StepContainerProps:
   ```typescript
   step8SelectedSlotIds?: string[];
   step8Crazy8sSlots?: Array<{ slotId: string; title: string; imageUrl?: string }>;
   ```

5. Do the same overlay placement in the mobile layout section where CANVAS_ONLY_STEPS renders.

**page.tsx:**
1. Add import for ConceptCardData:
   ```typescript
   import type { ConceptCardData } from '@/lib/canvas/concept-card-types';
   ```

2. Load concept cards from canvas state and pass to provider:
   After the existing `initialDrawingNodes` line, add:
   ```typescript
   const initialConceptCards: ConceptCardData[] = canvasData?.conceptCards || [];
   ```

3. Pass to CanvasStoreProvider:
   ```typescript
   <CanvasStoreProvider
     initialPostIts={initialCanvasPostIts}
     initialGridColumns={initialGridColumns}
     initialDrawingNodes={initialDrawingNodes}
     initialConceptCards={initialConceptCards}
   >
   ```

4. **Load Step 8 data for Step 9:** When step is 'concept' (Step 9), query Step 8 artifact for `selectedSketchSlotIds` and load Step 8 canvas for `crazy8sSlots`:
   ```typescript
   let step8SelectedSlotIds: string[] | undefined;
   let step8Crazy8sSlots: Array<{ slotId: string; title: string; imageUrl?: string }> | undefined;

   if (step.id === 'concept') {
     // Load Step 8 artifact for selectedSketchSlotIds
     const ideationStep = session.workshop.steps.find(s => s.stepId === 'ideation');
     if (ideationStep) {
       const ideationArtifacts = await db
         .select({ artifact: stepArtifacts.artifact })
         .from(stepArtifacts)
         .where(eq(stepArtifacts.workshopStepId, ideationStep.id))
         .limit(1);
       if (ideationArtifacts.length > 0) {
         const artifact = ideationArtifacts[0].artifact as Record<string, unknown>;
         step8SelectedSlotIds = artifact?.selectedSketchSlotIds as string[] | undefined;
       }
     }

     // Load Step 8 canvas state for crazy8sSlots
     const step8Canvas = await loadCanvasState(session.workshop.id, 'ideation');
     if (step8Canvas?.crazy8sSlots) {
       step8Crazy8sSlots = step8Canvas.crazy8sSlots.map(s => ({
         slotId: s.slotId,
         title: s.title,
         imageUrl: s.imageUrl,
       }));
     }
   }
   ```

5. Pass to StepContainer:
   ```typescript
   <StepContainer
     stepOrder={stepNumber}
     sessionId={sessionId}
     workshopId={session.workshop.id}
     initialMessages={initialMessages}
     initialArtifact={initialArtifact}
     stepStatus={stepRecord?.status}
     step8SelectedSlotIds={step8SelectedSlotIds}
     step8Crazy8sSlots={step8Crazy8sSlots}
   />
   ```

**output-panel.tsx:**
The output panel currently renders `ConceptSheetView` for Step 9. Since Step 9 is now a CANVAS_ONLY_STEP, the output panel won't be shown for Step 9 in the main layout. However, keep the existing Step 9 rendering code in output-panel.tsx for backward compatibility (it won't hurt and could be useful if the layout changes). No changes needed to output-panel.tsx.

IMPORTANT: Maintain all existing functionality. Only ADD new code for Step 9 canvas support. Do not remove or modify existing CANVAS_ONLY_STEPS or CANVAS_ENABLED_STEPS entries.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors. Run `npm run build` to verify production build succeeds. Verify 'concept' appears in both CANVAS_ENABLED_STEPS and CANVAS_ONLY_STEPS in step-container.tsx. Verify CanvasStoreProvider receives initialConceptCards. Verify page.tsx loads Step 8 data when step is 'concept'.
  </verify>
  <done>Step 9 renders with chat panel + ReactFlow canvas layout. Concept canvas overlay shows Generate button when no concepts exist. AI-generated concept cards appear on canvas with dealing-cards layout. Concept cards persist via CanvasStoreProvider initial state. Step 9 confirmed when concept cards exist.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. Step 9 uses canvas layout (CANVAS_ONLY_STEPS includes 'concept')
4. ConceptCanvasOverlay renders Generate button on empty Step 9 canvas
5. AI generation creates concept cards from selected Crazy 8s sketches
6. Concept cards appear on canvas with 30px x/y dealing-cards offset
7. Concept cards persist across page refresh
8. Step 9 is confirmed when conceptCards.length > 0
9. No regressions to Steps 2, 4, 5, 6 canvas behavior
</verification>

<success_criteria>
End-to-end flow works: User enters Step 9, sees selected Crazy 8s sketches context, clicks Generate, AI creates concept cards, cards appear on canvas with dealing-cards layout, user can drag/edit/collapse sections, state persists on refresh. Step navigation shows Step 9 as complete when concept cards exist.
</success_criteria>

<output>
After completion, create `.planning/phases/29-visual-concept-cards/29-04-SUMMARY.md`
</output>
