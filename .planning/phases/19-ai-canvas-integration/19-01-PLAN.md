---
phase: 19-ai-canvas-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/context/types.ts
  - src/lib/context/assemble-context.ts
  - src/lib/ai/chat-config.ts
  - src/app/api/chat/route.ts
autonomous: true

must_haves:
  truths:
    - "AI system prompt includes current canvas state as structured context"
    - "AI context includes stakeholders grouped by quadrant for Step 2"
    - "AI context includes insights grouped by quadrant for Step 4"
    - "AI system prompt instructs model to generate [CANVAS_ITEM] markup on Steps 2 and 4"
    - "Non-canvas steps have no canvas context in system prompt"
  artifacts:
    - path: "src/lib/context/types.ts"
      provides: "StepContext with canvasContext field"
      contains: "canvasContext"
    - path: "src/lib/context/assemble-context.ts"
      provides: "Canvas state loading and context assembly"
      contains: "assembleCanvasContextForStep"
    - path: "src/lib/ai/chat-config.ts"
      provides: "System prompt with canvas state and action instructions"
      contains: "CANVAS STATE"
    - path: "src/app/api/chat/route.ts"
      provides: "Canvas context passed to system prompt builder"
      contains: "canvasContext"
  key_links:
    - from: "src/lib/context/assemble-context.ts"
      to: "src/actions/canvas-actions.ts"
      via: "loadCanvasState import"
      pattern: "loadCanvasState"
    - from: "src/lib/context/assemble-context.ts"
      to: "src/lib/workshop/context/canvas-context.ts"
      via: "assembleCanvasContextForStep import"
      pattern: "assembleCanvasContextForStep"
    - from: "src/app/api/chat/route.ts"
      to: "src/lib/ai/chat-config.ts"
      via: "canvasContext parameter"
      pattern: "stepContext\\.canvasContext"
---

<objective>
Wire canvas context assembly into the AI pipeline so the AI system prompt includes current canvas state and instructs the model to generate [CANVAS_ITEM] markup.

Purpose: Enable AI to silently read canvas state (requirements AICV-03, STK-03, RSM-03) and generate action markup for client-side rendering (requirement AICV-01). This is the server-side half of bidirectional AI-canvas integration.

Output: Modified context pipeline where assembleStepContext loads canvas state, buildStepSystemPrompt injects canvas context + action instructions, and the chat route passes it all through.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-step-specific-canvases/18-02-SUMMARY.md

# Key source files
@src/lib/context/types.ts
@src/lib/context/assemble-context.ts
@src/lib/ai/chat-config.ts
@src/app/api/chat/route.ts
@src/lib/workshop/context/canvas-context.ts
@src/actions/canvas-actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add canvasContext to StepContext and wire into assembleStepContext</name>
  <files>src/lib/context/types.ts, src/lib/context/assemble-context.ts</files>
  <action>
  1. In `src/lib/context/types.ts`, add an optional `canvasContext` field to the `StepContext` interface:
     ```typescript
     canvasContext: string; // Canvas state formatted for AI prompt
     ```

  2. In `src/lib/context/assemble-context.ts`:
     - Import `loadCanvasState` from `@/actions/canvas-actions`
     - Import `assembleCanvasContextForStep` from `@/lib/workshop/context/canvas-context`
     - After Tier 3 (messages query), add a Tier 4 section that:
       a. Calls `loadCanvasState(workshopId, currentStepId)` to get canvas post-its from the database
       b. If post-its exist (`canvasState?.postIts?.length > 0`), calls `assembleCanvasContextForStep(currentStepId, canvasState.postIts)` to produce the formatted context string
       c. Otherwise sets `canvasContext` to empty string `''`
     - Add `canvasContext` to the returned `StepContext` object

  Note: `loadCanvasState` is a server action (has `'use server'` directive) but can be called from server-side code in the API route context without issues. The function queries stepArtifacts for the `_canvas` key in the JSONB artifact column.

  Note: `assembleCanvasContextForStep` is a pure function that routes to step-specific assembly (stakeholder quadrant grouping for Step 2, empathy map grouping for Step 4, flat list for other steps). It was created in Phase 18 and is ready to use.
  </action>
  <verify>
  Run `npx tsc --noEmit` from the project root — no TypeScript errors.
  Verify with grep: `grep -n "canvasContext" src/lib/context/types.ts src/lib/context/assemble-context.ts` shows the field in both files.
  Verify imports: `grep -n "loadCanvasState\|assembleCanvasContextForStep" src/lib/context/assemble-context.ts` shows both imports.
  </verify>
  <done>
  `assembleStepContext()` returns a `StepContext` with a `canvasContext` string field. When a step has canvas post-its in the database, the field contains quadrant-grouped text (Steps 2, 4) or a flat list (other steps). When no canvas data exists, the field is an empty string.
  </done>
</task>

<task type="auto">
  <name>Task 2: Inject canvas context and action instructions into system prompt</name>
  <files>src/lib/ai/chat-config.ts, src/app/api/chat/route.ts</files>
  <action>
  1. In `src/lib/ai/chat-config.ts`, modify `buildStepSystemPrompt()`:

     a. Add a `canvasContext` parameter (type `string`) after the `summaries` parameter and before `instructionsOverride?`:
        ```typescript
        export function buildStepSystemPrompt(
          stepId: string,
          stepName: string,
          arcPhase: ArcPhase,
          stepDescription: string,
          persistentContext: string,
          summaries: string,
          canvasContext: string, // NEW — Tier 4: Canvas state
          instructionsOverride?: string
        ): string {
        ```

     b. After the LONG-TERM MEMORY section (after `if (summaries) { ... }`), add a CANVAS STATE section:
        ```typescript
        // Add Tier 4: Canvas State
        if (canvasContext) {
          prompt += `\n\nCANVAS STATE (Visual workspace for this step):
        ${canvasContext}

        The canvas shows items the user has visually organized. Reference these naturally in conversation (e.g., "I see you have 3 stakeholders in the Manage Closely quadrant..."). Do not re-suggest items already on the canvas.`;
        }
        ```

     c. Update the CONTEXT USAGE RULES conditional to include `canvasContext`:
        Change `if (persistentContext || summaries)` to `if (persistentContext || summaries || canvasContext)`.
        Add a canvas-specific rule to the existing rules:
        `- Reference canvas items naturally when discussing ${stepId === 'stakeholder-mapping' ? 'stakeholders' : stepId === 'sense-making' ? 'insights' : 'items'}`

     d. After the SUGGESTED RESPONSES section (at the end, before `return prompt`), add a conditional CANVAS ACTIONS section for Steps 2 and 4 during gather/synthesize phases:
        ```typescript
        // Canvas action markup instructions (Steps 2 and 4 only, during gather/synthesize)
        if ((stepId === 'stakeholder-mapping' || stepId === 'sense-making') &&
            (arcPhase === 'gather' || arcPhase === 'synthesize')) {
          const itemType = stepId === 'stakeholder-mapping' ? 'stakeholders' : 'insights or observations';

          prompt += `\n\nCANVAS ACTIONS:
        When suggesting ${itemType} the user should add to their canvas, wrap each item in [CANVAS_ITEM]...[/CANVAS_ITEM] tags.
        This creates an "Add to canvas" button so they can add it with one click.

        Format: [CANVAS_ITEM]Brief item text (max 80 characters)[/CANVAS_ITEM]

        Example: "Here are key stakeholders to consider: [CANVAS_ITEM]Product Manager - high influence[/CANVAS_ITEM] and [CANVAS_ITEM]End Users - primary beneficiaries[/CANVAS_ITEM]"

        Guidelines:
        - Only use for concrete ${itemType} that belong on the canvas
        - Keep text brief (fits on a post-it note)
        - Do not wrap questions, explanations, or general text in these tags
        - Limit to 3-5 items per message to avoid overwhelming the user`;
        }
        ```

  2. In `src/app/api/chat/route.ts`, update the `buildStepSystemPrompt()` call to pass `canvasContext`:
     Change:
     ```typescript
     const systemPrompt = buildStepSystemPrompt(
       stepId, stepName, arcPhase, stepDescription,
       stepContext.persistentContext, stepContext.summaries,
       instructionsOverride
     );
     ```
     To:
     ```typescript
     const systemPrompt = buildStepSystemPrompt(
       stepId, stepName, arcPhase, stepDescription,
       stepContext.persistentContext, stepContext.summaries,
       stepContext.canvasContext, // NEW: Tier 4 canvas context
       instructionsOverride
     );
     ```
  </action>
  <verify>
  Run `npx tsc --noEmit` — no TypeScript errors.
  Run `npm run build` — build succeeds (ensures SSR safety and no import issues).
  Verify: `grep -n "CANVAS STATE\|CANVAS ACTIONS\|canvasContext" src/lib/ai/chat-config.ts` shows all three sections.
  Verify: `grep -n "canvasContext" src/app/api/chat/route.ts` shows the parameter being passed.
  </verify>
  <done>
  `buildStepSystemPrompt()` accepts a `canvasContext` parameter, injects it as a CANVAS STATE section in the system prompt when non-empty, and adds CANVAS ACTIONS instructions on Steps 2 and 4 during gather/synthesize arc phases. The chat route passes `stepContext.canvasContext` through to the prompt builder. Build succeeds with no errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero TypeScript errors
2. `npm run build` — build succeeds (SSR safety preserved)
3. `grep -rn "canvasContext" src/lib/context/ src/lib/ai/ src/app/api/chat/` — field flows from types.ts through assemble-context.ts to chat-config.ts to route.ts
4. `grep -n "assembleCanvasContextForStep" src/lib/context/assemble-context.ts` — Phase 18 function wired in
5. `grep -n "loadCanvasState" src/lib/context/assemble-context.ts` — canvas state loaded from DB
6. `grep -n "CANVAS STATE" src/lib/ai/chat-config.ts` — canvas context injected into prompt
7. `grep -n "CANVAS ACTIONS" src/lib/ai/chat-config.ts` — canvas item markup instructions present
8. `grep -n "CANVAS_ITEM" src/lib/ai/chat-config.ts` — markup format documented in prompt
</verification>

<success_criteria>
- assembleStepContext returns canvasContext string from database canvas state
- buildStepSystemPrompt includes CANVAS STATE section when canvas has post-its
- buildStepSystemPrompt includes CANVAS ACTIONS instructions on Steps 2 and 4 during gather/synthesize
- Chat route passes canvasContext through the pipeline
- TypeScript compiles and build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/19-ai-canvas-integration/19-01-SUMMARY.md`
</output>
