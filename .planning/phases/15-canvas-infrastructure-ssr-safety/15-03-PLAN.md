---
phase: 15-canvas-infrastructure-ssr-safety
plan: 03
type: execute
wave: 3
depends_on: ["15-01", "15-02"]
files_modified:
  - src/actions/canvas-actions.ts
  - src/hooks/use-canvas-autosave.ts
  - src/components/canvas/react-flow-canvas.tsx
  - src/app/workshop/[sessionId]/step/[stepId]/page.tsx
  - src/components/workshop/step-container.tsx
autonomous: true

must_haves:
  truths:
    - "Canvas state auto-saves to database debounced at 2 seconds"
    - "Canvas state loads from database when returning to step"
    - "Canvas data stored in existing stepArtifacts JSONB column"
    - "Save status indicator shows 'Saving...' and 'Saved' in canvas corner"
    - "Save retries silently up to 3 failures before showing warning"
    - "Canvas state force-saves when user navigates away"
    - "Post-its persist across page refresh and step navigation"
  artifacts:
    - path: "src/actions/canvas-actions.ts"
      provides: "Server actions for saving and loading canvas state"
      exports: ["saveCanvasState", "loadCanvasState"]
    - path: "src/hooks/use-canvas-autosave.ts"
      provides: "Auto-save hook with debounce, retry, force-save"
      exports: ["useCanvasAutosave"]
  key_links:
    - from: "src/hooks/use-canvas-autosave.ts"
      to: "src/actions/canvas-actions.ts"
      via: "calls saveCanvasState server action"
      pattern: "saveCanvasState"
    - from: "src/hooks/use-canvas-autosave.ts"
      to: "src/stores/canvas-store.ts"
      via: "reads postIts via useCanvasStore"
      pattern: "useCanvasStore"
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/hooks/use-canvas-autosave.ts"
      via: "uses useCanvasAutosave hook"
      pattern: "useCanvasAutosave"
    - from: "src/app/workshop/[sessionId]/step/[stepId]/page.tsx"
      to: "src/actions/canvas-actions.ts"
      via: "loads canvas state on server"
      pattern: "loadCanvasState"
    - from: "src/app/workshop/[sessionId]/step/[stepId]/page.tsx"
      to: "src/providers/canvas-store-provider.tsx"
      via: "wraps step with CanvasStoreProvider"
      pattern: "CanvasStoreProvider"
---

<objective>
Build the persistence layer for canvas state: server actions for save/load using existing stepArtifacts JSONB column, auto-save hook with 2s debounce and retry logic, force-save on navigation, and integrate canvas into the existing step page and step-container.

Purpose: Without persistence, all post-its are lost on page refresh. This plan ensures canvas state survives navigation, refresh, and session resumption by storing it in the existing database schema (no migration needed).

Output: 2 new files (server action, autosave hook), 3 modified files (canvas component, step page, step container).
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-canvas-infrastructure-ssr-safety/15-RESEARCH.md
@.planning/phases/15-canvas-infrastructure-ssr-safety/15-CONTEXT.md
@.planning/phases/15-canvas-infrastructure-ssr-safety/15-01-SUMMARY.md
@.planning/phases/15-canvas-infrastructure-ssr-safety/15-02-SUMMARY.md

# Critical existing files to read and modify:
@src/db/schema/step-artifacts.ts
@src/lib/context/save-artifact.ts
@src/hooks/use-auto-save.ts
@src/actions/auto-save-actions.ts
@src/app/workshop/[sessionId]/step/[stepId]/page.tsx
@src/components/workshop/step-container.tsx
@src/stores/canvas-store.ts
@src/providers/canvas-store-provider.tsx
@src/components/canvas/react-flow-canvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create server actions and auto-save hook for canvas persistence</name>
  <files>
    src/actions/canvas-actions.ts
    src/hooks/use-canvas-autosave.ts
  </files>
  <action>
    1. Create `src/actions/canvas-actions.ts` — Server actions for canvas CRUD:
       - Add `'use server'` directive
       - Import `db` from `@/db/client`, `stepArtifacts`, `workshopSteps` from `@/db/schema`, `eq`, `and` from `drizzle-orm`
       - Import `PostIt` type from `@/stores/canvas-store`

       **`saveCanvasState(workshopId: string, stepId: string, canvasState: { postIts: PostIt[] }): Promise<{ success: boolean; error?: string }>`**
       - Find the workshopStep record: query `workshopSteps` where `workshopId` and `stepId` match
       - If no workshopStep found, return `{ success: false, error: 'Workshop step not found' }`
       - Check for existing artifact: query `stepArtifacts` where `workshopStepId` matches
       - If existing: UPDATE with optimistic locking:
         - Set `artifact` to `canvasState` (the whole `{ postIts: [...] }` object)
         - Increment `version`
         - Set `extractedAt` to `new Date()`
         - WHERE `id = existing.id AND version = existing.version`
         - Note: Drizzle doesn't expose rowCount. For Phase 15, trust the WHERE clause. Log a warning if optimistic lock might have failed (per research: "log error for Phase 15, defer merge")
       - If NOT existing: INSERT new stepArtifact:
         - `workshopStepId`, `stepId`, `artifact: canvasState`, `schemaVersion: 'canvas-1.0'`, `version: 1`
       - Wrap in try/catch: return `{ success: false, error: message }` on failure
       - Return `{ success: true }` on success

       **`loadCanvasState(workshopId: string, stepId: string): Promise<{ postIts: PostIt[] } | null>`**
       - Find workshopStep by `workshopId` + `stepId`
       - If no workshopStep, return `null`
       - Query stepArtifacts by `workshopStepId`
       - If artifact exists AND artifact has `postIts` array: return `artifact as { postIts: PostIt[] }`
       - Otherwise return `null`
       - Note: This is NOT a server action (no mutation) — export as regular async function. But since the file has `'use server'` directive, all exports become server actions. That's fine for consistency with the existing `auto-save-actions.ts` pattern.

    2. Create `src/hooks/use-canvas-autosave.ts` — Auto-save hook:
       - Add `'use client'` directive (hooks are client-side)
       - Import `useEffect`, `useRef`, `useState`, `useCallback` from React
       - Import `useDebouncedCallback` from `use-debounce` (match existing `use-auto-save.ts` pattern)
       - Import `useCanvasStore` from `@/providers/canvas-store-provider`
       - Import `saveCanvasState` from `@/actions/canvas-actions`

       **`useCanvasAutosave(workshopId: string, stepId: string)`**

       a) **State:**
          - `saveStatus`: `'idle' | 'saving' | 'saved' | 'error'` (default: `'idle'`)
          - `failureCountRef` = useRef(0) — tracks consecutive failures

       b) **Store access:**
          - `postIts = useCanvasStore(s => s.postIts)`
          - `isDirty = useCanvasStore(s => s.isDirty)`
          - `markClean = useCanvasStore(s => s.markClean)`

       c) **Debounced save** (using `useDebouncedCallback` from `use-debounce`):
          - Debounce delay: 2000ms (2 seconds per locked decision)
          - maxWait: 10000ms (force save after 10s, matching existing chat auto-save pattern)
          - Callback:
            - If not dirty, skip (no changes to save)
            - Set `saveStatus` to `'saving'`
            - Call `saveCanvasState(workshopId, stepId, { postIts })`
            - On success: `markClean()`, set `saveStatus` to `'saved'`, reset `failureCountRef` to 0
            - After 2s timeout: set `saveStatus` back to `'idle'` (auto-clear "Saved" indicator)
            - On failure: increment `failureCountRef`
              - If `failureCountRef.current < 3`: log warning, set status to `'idle'` (silent retry — next change triggers save again)
              - If `failureCountRef.current >= 3`: set `saveStatus` to `'error'`, log error (per locked decision: show warning only after 3 consecutive failures)

       d) **Trigger save on postIt changes:**
          ```
          useEffect(() => {
            if (isDirty) {
              debouncedSave();
            }
          }, [postIts, isDirty, debouncedSave]);
          ```

       e) **Force-save on unmount** (matches existing `use-auto-save.ts` pattern):
          ```
          useEffect(() => {
            return () => {
              debouncedSave.flush();
            };
          }, [debouncedSave]);
          ```

       f) **Force-save on beforeunload** (per locked decision: force-save when user navigates away):
          ```
          useEffect(() => {
            const handleBeforeUnload = () => {
              debouncedSave.flush();
            };
            window.addEventListener('beforeunload', handleBeforeUnload);
            return () => window.removeEventListener('beforeunload', handleBeforeUnload);
          }, [debouncedSave]);
          ```

       g) **Return:** `{ saveStatus }` — consumed by canvas component for status indicator

  </action>
  <verify>
    - `npx tsc --noEmit` passes without type errors
    - `src/actions/canvas-actions.ts` exports `saveCanvasState` and `loadCanvasState`
    - `src/hooks/use-canvas-autosave.ts` exports `useCanvasAutosave`
    - Server action file has `'use server'` directive
    - Hook file has `'use client'` directive (even though hooks don't technically need it, follows convention)
    - Debounce set to 2000ms
    - Force-save on beforeunload and component unmount
    - Failure count tracked via useRef (not useState — avoids re-render on failure count change)
  </verify>
  <done>
    Canvas state saves to stepArtifacts JSONB column via server action with optimistic locking. Auto-save debounces at 2s with 10s maxWait. Silent retry for first 2 failures, error status after 3. Force-save on page unload and component unmount.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire canvas into step page with load/save and CanvasStoreProvider</name>
  <files>
    src/components/canvas/react-flow-canvas.tsx
    src/app/workshop/[sessionId]/step/[stepId]/page.tsx
    src/components/workshop/step-container.tsx
  </files>
  <action>
    1. **Modify `src/components/canvas/react-flow-canvas.tsx`** — Add autosave integration:
       - Import `useCanvasAutosave` from `@/hooks/use-canvas-autosave`
       - In `ReactFlowCanvasInner`, call the hook:
         ```
         const { saveStatus } = useCanvasAutosave(workshopId, stepId);
         ```
       - Update props to accept `workshopId: string` in addition to `sessionId` and `stepId`
       - Wire up the save status indicator in the bottom-right corner:
         ```
         <div className="absolute bottom-3 right-3 z-10 text-xs text-muted-foreground flex items-center gap-1.5">
           {saveStatus === 'saving' && (
             <>
               <span className="h-1.5 w-1.5 rounded-full bg-yellow-500 animate-pulse" />
               Saving...
             </>
           )}
           {saveStatus === 'saved' && (
             <>
               <span className="h-1.5 w-1.5 rounded-full bg-green-500" />
               Saved
             </>
           )}
           {saveStatus === 'error' && (
             <>
               <span className="h-1.5 w-1.5 rounded-full bg-red-500" />
               Save failed
             </>
           )}
         </div>
         ```
       - Also update `CanvasWrapper` in `canvas-wrapper.tsx` to pass `workshopId` prop through

    2. **Modify `src/components/canvas/canvas-wrapper.tsx`** — Add workshopId prop:
       - Update props interface to include `workshopId: string`
       - Pass `workshopId` through to `ReactFlowCanvas`

    3. **Modify `src/app/workshop/[sessionId]/step/[stepId]/page.tsx`** — Load canvas state and wrap with provider:
       - Import `CanvasStoreProvider` from `@/providers/canvas-store-provider`
       - Import `loadCanvasState` from `@/actions/canvas-actions`
       - Import `PostIt` type from `@/stores/canvas-store`
       - After existing session/step queries, load canvas state:
         ```
         // Load canvas state for this step
         const canvasData = await loadCanvasState(session.workshop.id, step.id);
         const initialCanvasPostIts: PostIt[] = canvasData?.postIts || [];
         ```
       - Wrap the `StepContainer` with `CanvasStoreProvider`:
         ```
         <CanvasStoreProvider initialPostIts={initialCanvasPostIts}>
           <StepContainer
             stepOrder={stepNumber}
             sessionId={sessionId}
             workshopId={session.workshop.id}
             initialMessages={initialMessages}
             initialArtifact={initialArtifact}
             stepStatus={stepRecord?.status}
           />
         </CanvasStoreProvider>
         ```
       - This ensures the canvas store is initialized with DB data BEFORE any canvas component renders

    4. **Modify `src/components/workshop/step-container.tsx`** — Add canvas to the right panel:
       - Import `CanvasWrapper` from `@/components/canvas/canvas-wrapper`
       - Import `getStepByOrder` (already imported)
       - For Phase 15, render canvas in the RIGHT panel (where `OutputPanel` currently lives):
         - Keep the existing OutputPanel for steps that have artifacts
         - Add canvas below/alongside the output panel as a new section
         - Actually, per Phase 16 (Split-Screen Layout), the layout will be restructured. For Phase 15, the simplest integration is:
           - Add `CanvasWrapper` to the output panel area, visible for ALL steps (canvas is step-agnostic in Phase 15)
           - The canvas renders BELOW the existing output panel content
           - OR: Since Phase 16 handles the proper split-screen, for Phase 15 just make the canvas accessible:
             - Replace the output panel content with canvas when no artifact exists
             - Keep output panel when artifact exists
       - SIMPLEST APPROACH for Phase 15 (will be restructured in Phase 16):
         - In `renderOutput()`, add the canvas wrapper at the TOP of the output panel, taking available space
         - When artifact exists, show both canvas and artifact (canvas above, artifact below)
         - When no artifact, canvas takes full height
         - This gives immediate visual access to the canvas on every step
       - Pass `workshopId` and `stepId` (from step-metadata lookup) to `CanvasWrapper`:
         ```
         const stepMeta = getStepByOrder(stepOrder);
         <CanvasWrapper
           sessionId={sessionId}
           stepId={stepMeta?.id || ''}
           workshopId={workshopId}
         />
         ```
       - For the mobile layout, stack canvas above the output content
       - The canvas container needs a fixed minimum height: `min-h-[300px]` on mobile, `flex-1` on desktop

  </action>
  <verify>
    - `npx tsc --noEmit` passes without type errors
    - `npm run build` succeeds (full Next.js build — tests SSR safety)
    - Step page wraps StepContainer in CanvasStoreProvider
    - Canvas state loads from database on page render (server component fetches, passes to provider)
    - Canvas visible in right panel of step page
    - Save status indicator appears in bottom-right of canvas
    - Navigate away from step and back — post-its persist
    - Create post-it, wait 3 seconds, refresh page — post-it still there
  </verify>
  <done>
    Canvas state loads from database via server component on page render. CanvasStoreProvider wraps step with initial state from DB. Auto-save writes changes to stepArtifacts JSONB column debounced at 2s. Save status indicator shows "Saving..." / "Saved" / "Save failed" in canvas corner. Force-save on navigation prevents data loss. Post-its persist across page refresh and step navigation.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` — full Next.js build succeeds (validates SSR safety end-to-end)
2. `npx tsc --noEmit` — no type errors
3. Create post-its, wait for "Saved" indicator, refresh page — post-its reload
4. Navigate between steps and back — canvas state persists
5. Canvas uses existing stepArtifacts table (no new migrations needed)
6. Save indicator shows "Saving..." during save, "Saved" after success
7. Force-save triggers on page close (beforeunload) and component unmount
</verification>

<success_criteria>
- Canvas state auto-saves to stepArtifacts JSONB column (debounced 2s)
- Canvas state loads from database when returning to step
- No new database migrations needed (uses existing stepArtifacts.artifact column)
- Save status indicator visible in bottom-right corner
- Silent retry for up to 3 failures before showing error
- Force-save on navigation away (no unsaved changes dialog)
- Full round-trip works: create post-its -> auto-save -> refresh page -> post-its appear
</success_criteria>

<output>
After completion, create `.planning/phases/15-canvas-infrastructure-ssr-safety/15-03-SUMMARY.md`
</output>
