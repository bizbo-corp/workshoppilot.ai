---
phase: 47-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/users.ts
  - src/db/schema/workshops.ts
  - src/db/schema/credit-transactions.ts
  - src/db/schema/index.ts
  - src/db/schema/relations.ts
  - drizzle/0008_*.sql
autonomous: true
requirements: [BILL-04, BILL-05, CRED-03, ONBD-03]

must_haves:
  truths:
    - "users table has creditBalance (int, default 0), onboardingComplete (bool, default false), stripeCustomerId (text, nullable), and planTier (text, default 'free') columns"
    - "workshops table has creditConsumedAt (timestamp, nullable) column"
    - "credit_transactions table exists with id, clerkUserId, type enum, status enum, amount, balanceAfter, description, workshopId FK, stripeSessionId UNIQUE, createdAt"
    - "Drizzle migration 0008 runs cleanly with zero errors"
    - "All existing data is preserved — no rows dropped, no columns removed"
  artifacts:
    - path: "src/db/schema/users.ts"
      provides: "User schema with billing and onboarding columns"
      contains: "creditBalance"
    - path: "src/db/schema/workshops.ts"
      provides: "Workshop schema with credit consumption tracking"
      contains: "creditConsumedAt"
    - path: "src/db/schema/credit-transactions.ts"
      provides: "Credit transaction ledger table"
      exports: ["creditTransactions"]
    - path: "src/db/schema/index.ts"
      provides: "Barrel export including credit-transactions"
      contains: "credit-transactions"
    - path: "src/db/schema/relations.ts"
      provides: "Drizzle relations including creditTransactions"
      contains: "creditTransactionsRelations"
    - path: "drizzle/0008_*.sql"
      provides: "Migration SQL for all schema changes"
  key_links:
    - from: "src/db/schema/credit-transactions.ts"
      to: "src/db/schema/workshops.ts"
      via: "workshopId foreign key reference"
      pattern: "references.*workshops\\.id"
    - from: "src/db/schema/index.ts"
      to: "src/db/schema/credit-transactions.ts"
      via: "barrel export"
      pattern: "export.*credit-transactions"
    - from: "src/db/schema/relations.ts"
      to: "src/db/schema/credit-transactions.ts"
      via: "relation definition import"
      pattern: "creditTransactions"
---

<objective>
Add billing and onboarding columns to the users and workshops tables, create the credit_transactions ledger table, update Drizzle relations, and run the migration on the Neon database.

Purpose: Establish the complete database schema for the v1.8 payment and onboarding system so that no subsequent phase (48-53) requires any schema changes.

Output: Updated schema files, new credit-transactions schema, updated relations, and a successfully applied migration (0008).
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-database-foundation/47-RESEARCH.md

@src/db/schema/users.ts
@src/db/schema/workshops.ts
@src/db/schema/index.ts
@src/db/schema/relations.ts
@drizzle.config.ts

<interfaces>
<!-- Existing schema patterns the executor needs to follow -->

From src/db/schema/users.ts:
```typescript
import { pgTable, text, timestamp, index } from 'drizzle-orm/pg-core';
import { createPrefixedId } from '@/lib/ids';

export const users = pgTable('users', {
  id: text('id').primaryKey().$defaultFn(() => createPrefixedId('usr')),
  clerkUserId: text('clerk_user_id').notNull().unique(),
  email: text('email').notNull(),
  firstName: text('first_name'),
  lastName: text('last_name'),
  imageUrl: text('image_url'),
  company: text('company'),
  roles: text('roles').notNull().default('["facilitator"]'),
  deletedAt: timestamp('deleted_at', { mode: 'date', precision: 3 }),
  createdAt: timestamp('created_at', { mode: 'date', precision: 3 }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date', precision: 3 }).notNull().defaultNow().$onUpdate(() => new Date()),
}, (table) => ({
  clerkUserIdIdx: index('users_clerk_user_id_idx').on(table.clerkUserId),
  emailIdx: index('users_email_idx').on(table.email),
}));
```

From src/db/schema/workshops.ts (text enum pattern):
```typescript
status: text('status', {
  enum: ['draft', 'active', 'paused', 'completed'],
}).notNull().default('draft').$type<'draft' | 'active' | 'paused' | 'completed'>(),
```

From src/lib/ids.ts:
```typescript
export function createPrefixedId(prefix: string): string;
// Prefixes used: ws, wm, sd, wst, ses, bp
// New prefix for credit transactions: ctx
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add billing and onboarding columns to users and workshops schemas</name>
  <files>src/db/schema/users.ts, src/db/schema/workshops.ts</files>
  <action>
Edit `src/db/schema/users.ts`:
1. Add `integer` and `boolean` to the import from `drizzle-orm/pg-core`
2. Add these four columns AFTER the existing `updatedAt` column (but BEFORE the closing of the columns object):
   - `creditBalance: integer('credit_balance').notNull().default(0)` — tracks current credit count
   - `onboardingComplete: boolean('onboarding_complete').notNull().default(false)` — DB-backed onboarding state (ONBD-03)
   - `stripeCustomerId: text('stripe_customer_id')` — nullable, for future Stripe Customer Portal
   - `planTier: text('plan_tier').notNull().default('free')` — future-proofing for subscription model
3. Add an index on stripeCustomerId: `stripeCustomerIdIdx: index('users_stripe_customer_id_idx').on(table.stripeCustomerId)` in the table's index function

IMPORTANT: Do NOT add `deletedAt` or `updatedAt` — they already exist. The CONTEXT.md decision to "add" these is already satisfied by the current schema.

Edit `src/db/schema/workshops.ts`:
1. Add this column AFTER `deletedAt` in the workshops table:
   - `creditConsumedAt: timestamp('credit_consumed_at', { mode: 'date', precision: 3 })` — nullable, marks when a credit was consumed for this workshop

Do NOT modify workshopMembers or any other table in this file.
  </action>
  <verify>
    <automated>cd /Users/michaelchristie/devProjects/workshoppilot.ai && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - users.ts has creditBalance (integer, default 0), onboardingComplete (boolean, default false), stripeCustomerId (text, nullable), planTier (text, default 'free')
    - workshops.ts has creditConsumedAt (timestamp, nullable)
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create credit_transactions ledger table and update barrel exports and relations</name>
  <files>src/db/schema/credit-transactions.ts, src/db/schema/index.ts, src/db/schema/relations.ts</files>
  <action>
Create `src/db/schema/credit-transactions.ts`:
1. Import `pgTable, text, integer, timestamp, index` from `drizzle-orm/pg-core`
2. Import `createPrefixedId` from `@/lib/ids`
3. Import `workshops` from `./workshops`
4. Define `creditTransactions` table with:
   - `id: text('id').primaryKey().$defaultFn(() => createPrefixedId('ctx'))` — prefixed CUID2
   - `clerkUserId: text('clerk_user_id').notNull()` — links to users via clerk ID (same pattern as workshops)
   - `type: text('type', { enum: ['purchase', 'consumption', 'refund'] }).notNull().$type<'purchase' | 'consumption' | 'refund'>()` — use TEXT enum for consistency with workshops.status pattern (not pgEnum)
   - `status: text('status', { enum: ['pending', 'completed', 'failed'] }).notNull().default('pending').$type<'pending' | 'completed' | 'failed'>()` — TEXT enum for async Stripe flow
   - `amount: integer('amount').notNull()` — signed integer (+1 purchase, -1 consumption, negative for refunds)
   - `balanceAfter: integer('balance_after').notNull()` — running balance after this transaction
   - `description: text('description').notNull()` — human-readable context
   - `workshopId: text('workshop_id').references(() => workshops.id, { onDelete: 'set null' })` — nullable FK, links consumption to workshop. Use `onDelete: 'set null'` (NOT cascade) because financial records must persist even if workshop is deleted
   - `stripeSessionId: text('stripe_session_id').unique()` — nullable + UNIQUE enforces idempotent webhook fulfillment (BILL-04). PG allows multiple NULLs with UNIQUE, which is correct for consumption transactions that have no Stripe session
   - `createdAt: timestamp('created_at', { mode: 'date', precision: 3 }).notNull().defaultNow()`
5. Add indexes:
   - `clerkUserIdIdx: index('credit_transactions_clerk_user_id_idx').on(table.clerkUserId)` — query user's transaction history
   - `typeIdx: index('credit_transactions_type_idx').on(table.type)` — filter by transaction type
   - `workshopIdIdx: index('credit_transactions_workshop_id_idx').on(table.workshopId)` — find transactions for a workshop

Export the table: `export const creditTransactions = pgTable(...)`.

Edit `src/db/schema/index.ts`:
Add `export * from './credit-transactions';` after the existing exports, before `export * from './relations';`.

Edit `src/db/schema/relations.ts`:
1. Add import: `import { creditTransactions } from './credit-transactions';`
2. Add to the existing `usersRelations`:
   - Add `creditTransactions: many(creditTransactions)` to the users relation (after workshops)
3. Add to the existing `workshopsRelations`:
   - Add `creditTransactions: many(creditTransactions)` (after aiUsageEvents)
4. Add a new relation block:
```typescript
/**
 * Credit Transactions relations
 */
export const creditTransactionsRelations = relations(creditTransactions, ({ one }) => ({
  workshop: one(workshops, {
    fields: [creditTransactions.workshopId],
    references: [workshops.id],
  }),
}));
```

Note: creditTransactions → users relation uses clerkUserId (text match, not FK) — same pattern as workshops → users. Do NOT add a `references()` constraint on clerkUserId in the schema (the existing workshops table uses the same pattern — logical relation via text match).
  </action>
  <verify>
    <automated>cd /Users/michaelchristie/devProjects/workshoppilot.ai && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - credit-transactions.ts exists with all columns: id, clerkUserId, type, status, amount, balanceAfter, description, workshopId, stripeSessionId, createdAt
    - stripeSessionId has UNIQUE constraint (idempotent webhook — BILL-04)
    - type enum includes purchase, consumption, refund
    - status enum includes pending, completed, failed
    - workshopId FK uses onDelete: 'set null'
    - index.ts barrel exports credit-transactions
    - relations.ts has creditTransactionsRelations with workshop relation
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Generate and apply Drizzle migration</name>
  <files>drizzle/0008_*.sql</files>
  <action>
Run the Drizzle migration generation and application workflow:

1. Run `npm run db:generate` to generate migration 0008 from the schema diff
2. Inspect the generated SQL file (in `drizzle/0008_*.sql`) and verify:
   - ALTER TABLE "users" ADD COLUMN for: credit_balance (integer DEFAULT 0 NOT NULL), onboarding_complete (boolean DEFAULT false NOT NULL), stripe_customer_id (text), plan_tier (text DEFAULT 'free' NOT NULL)
   - ALTER TABLE "workshops" ADD COLUMN for: credit_consumed_at (timestamp)
   - CREATE TABLE "credit_transactions" with all columns
   - CREATE INDEX for the new indexes
   - NO DROP statements (verify nothing is being removed)
   - NO ALTER TABLE statements that rename or remove existing columns
   - NO CREATE TYPE statements (we used text enums, not pgEnum)
   - The migration does NOT try to add deleted_at or updated_at to users (they already exist)
3. If the SQL looks correct, run `npm run db:migrate` to apply to the Neon database
4. Verify migration succeeded with no errors

CRITICAL: If `db:generate` produces SQL that drops columns, removes tables, or rewrites existing data — STOP and report. This phase is additive-only.

If the migration file number is not 0008 (e.g., because snapshots differ), that's fine — Drizzle auto-numbers.
  </action>
  <verify>
    <automated>cd /Users/michaelchristie/devProjects/workshoppilot.ai && ls drizzle/0008_*.sql 2>/dev/null || ls drizzle/*.sql | tail -1</automated>
  </verify>
  <done>
    - Migration SQL file exists in drizzle/ directory
    - Migration applied successfully to Neon database
    - No errors during generate or migrate
    - SQL is additive-only (no DROP, no data loss)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. Migration file exists in `drizzle/` directory with correct ALTER TABLE and CREATE TABLE statements
3. `npm run db:migrate` completed without errors
4. Existing application still works — no runtime regressions from schema changes (all new columns have defaults or are nullable)
</verification>

<success_criteria>
- users table has creditBalance (int, default 0) and onboardingComplete (bool, default false) columns
- users table has stripeCustomerId (varchar, nullable) and planTier (text, default 'free') columns
- workshops table has creditConsumedAt (timestamp, nullable) column
- credit_transactions ledger table exists with stripeSessionId UNIQUE constraint, type enum (purchase | consumption | refund), status enum (pending | completed | failed), and clerkUserId
- Drizzle migration runs cleanly on production Neon database with zero downtime
- All existing data preserved — zero row or column loss
</success_criteria>

<output>
After completion, create `.planning/phases/47-database-foundation/47-01-SUMMARY.md`
</output>
