---
phase: 47-database-foundation
plan: 02
type: execute
wave: 2
depends_on: [47-01]
files_modified:
  - scripts/seed-billing.ts
  - package.json
autonomous: true
requirements: [BILL-05, CRED-03]

must_haves:
  truths:
    - "Running npm run db:seed:billing creates seed users with various billing states"
    - "Running npm run db:seed:billing a second time does not create duplicates (idempotent)"
    - "Seed data covers: zero credits, positive credits, transaction history, refund, mid-onboarding, and workshop with creditConsumedAt"
  artifacts:
    - path: "scripts/seed-billing.ts"
      provides: "Idempotent seed script for billing development data"
      min_lines: 80
    - path: "package.json"
      provides: "db:seed:billing npm script"
      contains: "db:seed:billing"
  key_links:
    - from: "scripts/seed-billing.ts"
      to: "src/db/schema/index.ts"
      via: "imports users, creditTransactions, workshops"
      pattern: "from.*src/db/schema"
    - from: "package.json"
      to: "scripts/seed-billing.ts"
      via: "npm script definition"
      pattern: "seed-billing"
---

<objective>
Create an idempotent seed script that populates the database with comprehensive billing and onboarding development data, covering all the scenarios needed for Phase 48-53 development.

Purpose: Enable developers to quickly set up realistic billing states for testing payment flows, credit enforcement, paywall UI, and onboarding without manually creating records.

Output: `scripts/seed-billing.ts` script and `db:seed:billing` npm command.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-database-foundation/47-RESEARCH.md
@.planning/phases/47-database-foundation/47-01-SUMMARY.md

@scripts/seed-workshop.ts
@src/db/schema/users.ts
@src/db/schema/workshops.ts
@src/db/schema/credit-transactions.ts
@src/db/schema/index.ts
@src/db/client.ts

<interfaces>
<!-- Schema types available after Plan 01 -->

From src/db/schema/users.ts (after Plan 01):
```typescript
export const users = pgTable('users', {
  id: text('id').primaryKey().$defaultFn(() => createPrefixedId('usr')),
  clerkUserId: text('clerk_user_id').notNull().unique(),
  email: text('email').notNull(),
  creditBalance: integer('credit_balance').notNull().default(0),
  onboardingComplete: boolean('onboarding_complete').notNull().default(false),
  stripeCustomerId: text('stripe_customer_id'),
  planTier: text('plan_tier').notNull().default('free'),
  // ... other columns
});
```

From src/db/schema/credit-transactions.ts (after Plan 01):
```typescript
export const creditTransactions = pgTable('credit_transactions', {
  id: text('id').primaryKey().$defaultFn(() => createPrefixedId('ctx')),
  clerkUserId: text('clerk_user_id').notNull(),
  type: text('type', { enum: ['purchase', 'consumption', 'refund'] }).notNull(),
  status: text('status', { enum: ['pending', 'completed', 'failed'] }).notNull().default('pending'),
  amount: integer('amount').notNull(),
  balanceAfter: integer('balance_after').notNull(),
  description: text('description').notNull(),
  workshopId: text('workshop_id').references(() => workshops.id, { onDelete: 'set null' }),
  stripeSessionId: text('stripe_session_id').unique(),
  createdAt: timestamp('created_at', { mode: 'date', precision: 3 }).notNull().defaultNow(),
});
```

From src/db/schema/workshops.ts (after Plan 01):
```typescript
// workshops now includes:
creditConsumedAt: timestamp('credit_consumed_at', { mode: 'date', precision: 3 }),
```

From scripts/seed-workshop.ts (existing pattern):
```typescript
import { db } from '../src/db/client';
import { workshops, sessions, workshopSteps } from '../src/db/schema';
import { createPrefixedId } from '../src/lib/ids';
// Uses direct db import, dotenv loaded via npm script prefix
```

Existing npm scripts pattern:
```json
"db:seed:workshop": "dotenv -e .env.local -- tsx scripts/seed-workshop.ts"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create idempotent billing seed script</name>
  <files>scripts/seed-billing.ts</files>
  <action>
Create `scripts/seed-billing.ts` following the existing `seed-workshop.ts` pattern (imports from `../src/db/client`, uses `../src/lib/ids`).

The script must be idempotent: check if seed data already exists before inserting. Use `onConflictDoNothing()` on inserts keyed by `clerkUserId` unique constraint (for users) to prevent duplicates on re-run.

Create these seed scenarios (each as a separate seed user with a recognizable `clerkUserId` prefix `user_seed_billing_*`):

**Scenario 1: Zero credits, new user (pre-purchase)**
- User: `clerkUserId: 'user_seed_billing_zero'`, email: `billing-zero@seed.test`, creditBalance: 0, onboardingComplete: false, planTier: 'free'
- No transactions, no workshops
- Use case: Testing paywall UI (Phase 51)

**Scenario 2: User with credits (post-purchase, pre-workshop)**
- User: `clerkUserId: 'user_seed_billing_funded'`, email: `billing-funded@seed.test`, creditBalance: 3, onboardingComplete: true, planTier: 'free'
- One purchase transaction: type 'purchase', status 'completed', amount 3, balanceAfter 3, description 'Purchased Serial Entrepreneur pack', stripeSessionId 'cs_seed_funded_001'
- No workshops yet
- Use case: Testing credit consumption (Phase 50)

**Scenario 3: User with transaction history (multiple purchases + consumption)**
- User: `clerkUserId: 'user_seed_billing_active'`, email: `billing-active@seed.test`, creditBalance: 1, onboardingComplete: true, planTier: 'free'
- Workshop: title 'Seed: Active Workshop', originalIdea 'Testing credit flow', status 'active', creditConsumedAt set to a past date
- Transactions (in chronological order, use explicit createdAt dates):
  1. type 'purchase', status 'completed', amount 1, balanceAfter 1, description 'Purchased Single Flight', stripeSessionId 'cs_seed_active_001'
  2. type 'consumption', status 'completed', amount -1, balanceAfter 0, description 'Credit consumed for Workshop: Active Workshop', workshopId linked to the workshop above, stripeSessionId null
  3. type 'purchase', status 'completed', amount 3, balanceAfter 3, description 'Purchased Serial Entrepreneur pack', stripeSessionId 'cs_seed_active_002'
  4. type 'consumption', status 'completed', amount -1, balanceAfter 2, description 'Credit consumed for another workshop', stripeSessionId null
  5. type 'consumption', status 'completed', amount -1, balanceAfter 1, description 'Credit consumed for yet another workshop', stripeSessionId null
- Use case: Testing transaction ledger display (BILL-05), balance auditing

**Scenario 4: User with refund**
- User: `clerkUserId: 'user_seed_billing_refund'`, email: `billing-refund@seed.test`, creditBalance: 0, onboardingComplete: true, planTier: 'free'
- Transactions:
  1. type 'purchase', status 'completed', amount 1, balanceAfter 1, stripeSessionId 'cs_seed_refund_001'
  2. type 'refund', status 'completed', amount -1, balanceAfter 0, description 'Refund for Single Flight', stripeSessionId 'cs_seed_refund_002'
- Use case: Testing refund flow

**Scenario 5: Pending transaction (Stripe session created, webhook not yet received)**
- User: `clerkUserId: 'user_seed_billing_pending'`, email: `billing-pending@seed.test`, creditBalance: 0, onboardingComplete: true, planTier: 'free'
- One transaction: type 'purchase', status 'pending', amount 1, balanceAfter 1, stripeSessionId 'cs_seed_pending_001'
- Use case: Testing async Stripe flow, pending state handling

**Implementation notes:**
- Use `createPrefixedId('usr')` for user IDs, `createPrefixedId('ws')` for workshop IDs, `createPrefixedId('ctx')` for transaction IDs — but store them in variables so workshopId can be referenced in transactions
- For idempotency: wrap all inserts in a check — query for `user_seed_billing_zero` first; if found, log "Billing seed data already exists. Skipping." and return. This is simpler than per-record onConflictDoNothing since the scenarios are interdependent (transactions reference workshop IDs).
- Use `await db.insert(users).values([...]).onConflictDoNothing()` as a safety net even with the check
- For transactions that reference a workshopId, insert the workshop first and capture the ID
- Log each scenario as it's created for CLI feedback
- End with `process.exit(0)` to prevent the script from hanging (Neon connection stays open)
  </action>
  <verify>
    <automated>cd /Users/michaelchristie/devProjects/workshoppilot.ai && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - scripts/seed-billing.ts exists with all 5 scenarios
    - Script uses idempotency check (query before insert)
    - Script imports from ../src/db/client and ../src/db/schema
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add db:seed:billing npm script and run seed</name>
  <files>package.json</files>
  <action>
Edit `package.json` to add the `db:seed:billing` npm script.

Add this line after the existing `"db:seed:workshop"` line:
```json
"db:seed:billing": "dotenv -e .env.local -- tsx scripts/seed-billing.ts",
```

This follows the exact same pattern as `db:seed:workshop`. Do NOT modify or replace the existing `db:seed` or `db:seed:workshop` scripts.

After adding the script, run it:
1. `npm run db:seed:billing` — should create all seed data
2. `npm run db:seed:billing` — run again, should output "already exists" message (idempotency check)
  </action>
  <verify>
    <automated>cd /Users/michaelchristie/devProjects/workshoppilot.ai && grep -c "db:seed:billing" package.json</automated>
  </verify>
  <done>
    - package.json has db:seed:billing script pointing to scripts/seed-billing.ts
    - Existing db:seed and db:seed:workshop scripts are unchanged
    - npm run db:seed:billing runs successfully
    - Running it twice does not create duplicate records
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. `npm run db:seed:billing` creates seed data successfully
3. `npm run db:seed:billing` (second run) shows idempotency message and creates no duplicates
4. package.json has db:seed:billing alongside existing seed scripts (not replacing them)
</verification>

<success_criteria>
- Idempotent seed script creates 5 billing scenarios covering zero credits, funded user, transaction history, refund, and pending transaction
- Seed data includes credit_transactions records demonstrating the ledger (BILL-05)
- Seed data includes users with various creditBalance values for testing atomic operations (CRED-03)
- npm run db:seed:billing is runnable and re-runnable without duplicates
- Existing npm scripts (db:seed, db:seed:workshop) are unmodified
</success_criteria>

<output>
After completion, create `.planning/phases/47-database-foundation/47-02-SUMMARY.md`
</output>
