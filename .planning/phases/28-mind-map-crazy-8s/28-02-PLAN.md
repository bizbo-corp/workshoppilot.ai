---
phase: 28-mind-map-crazy-8s
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - src/lib/canvas/mind-map-layout.ts
  - src/components/workshop/mind-map-canvas.tsx
  - src/stores/canvas-store.ts
autonomous: true

must_haves:
  truths:
    - "Mind map displays HMW statement as central root node"
    - "Adding a child node triggers dagre layout recalculation and nodes reposition smoothly"
    - "Deleting a node cascades to children and triggers layout recalculation"
    - "Editing a node label does NOT trigger layout recalculation (no thrashing)"
    - "Mind map state (nodes + edges) persists in canvas store"
    - "Undo/redo works for mind map node add/delete operations"
  artifacts:
    - path: "src/lib/canvas/mind-map-layout.ts"
      provides: "Dagre-based auto-layout for mind map tree"
      exports: ["getLayoutedElements"]
    - path: "src/components/workshop/mind-map-canvas.tsx"
      provides: "Complete mind map ReactFlow canvas with CRUD operations"
      exports: ["MindMapCanvas"]
    - path: "src/stores/canvas-store.ts"
      provides: "Mind map state (mindMapNodes, mindMapEdges) in canvas store"
      contains: "mindMapNodes"
  key_links:
    - from: "src/components/workshop/mind-map-canvas.tsx"
      to: "src/lib/canvas/mind-map-layout.ts"
      via: "useMemo layout calculation"
      pattern: "getLayoutedElements"
    - from: "src/components/workshop/mind-map-canvas.tsx"
      to: "src/stores/canvas-store.ts"
      via: "Zustand store selectors"
      pattern: "useCanvasStore"
    - from: "src/components/workshop/mind-map-canvas.tsx"
      to: "src/components/canvas/mind-map-node.tsx"
      via: "nodeTypes registration"
      pattern: "mindMapNode.*MindMapNode"
---

<objective>
Build the MindMapCanvas component with dagre auto-layout and full CRUD operations (add/edit/delete nodes), backed by canvas store for persistence.

Purpose: This is the core mind map experience for Step 8a. Users see the HMW statement as the central node and can build themed idea branches up to 3 levels deep. dagre handles automatic tree positioning so users focus on ideas, not layout.

Output: Layout algorithm, canvas component, and store extensions for mind map state management.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-mind-map-crazy-8s/28-RESEARCH.md
@.planning/phases/28-mind-map-crazy-8s/28-01-SUMMARY.md

# Reference: existing canvas store and ReactFlow canvas patterns
@src/stores/canvas-store.ts
@src/components/canvas/react-flow-canvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dagre layout utility and extend canvas store with mind map state</name>
  <files>
    src/lib/canvas/mind-map-layout.ts
    src/stores/canvas-store.ts
  </files>
  <action>
**mind-map-layout.ts:**
Install dagre dependency first: `npm install dagre @types/dagre`

Create layout utility wrapping dagre for mind map tree layout:

```typescript
import dagre from 'dagre';
import type { Node, Edge } from '@xyflow/react';
```

Constants:
- `NODE_WIDTH = 200` (matches mind-map-node.tsx fixed width)
- `NODE_HEIGHT = 80` (node content height estimate)

Export `getLayoutedElements(nodes: Node[], edges: Edge[], options?: { direction?: 'TB' | 'LR' })`:
- Default direction: 'LR' (left-to-right horizontal tree)
- Create new `dagre.graphlib.Graph()`, set default edge label to `() => ({})`
- Configure graph: `rankdir: direction, ranksep: 120, nodesep: 100, edgesep: 50, marginx: 30, marginy: 30`
  - ranksep 120 and nodesep 100 per research pitfall #3 (prevent overlap with deep nesting)
- Add each node: `dagreGraph.setNode(node.id, { width: NODE_WIDTH, height: NODE_HEIGHT })`
- Add each edge: `dagreGraph.setEdge(edge.source, edge.target)`
- Run `dagre.layout(dagreGraph)`
- Map nodes to layouted positions: dagre returns center coordinates, convert to top-left by subtracting half width/height
- Return `{ nodes: layoutedNodes, edges }` (edges unchanged, positions updated on nodes)

**canvas-store.ts:**
Add mind map state alongside existing postIts, drawingNodes, gridColumns:

New types (at top of file):
```typescript
export type MindMapNodeState = {
  id: string;
  label: string;
  themeColorId: string;
  themeColor: string;
  themeBgColor: string;
  isRoot: boolean;
  level: number;          // 0 = root, 1 = theme branch, 2+ = sub-ideas
  parentId?: string;      // ID of parent node (undefined for root)
};

export type MindMapEdgeState = {
  id: string;
  source: string;
  target: string;
  themeColor: string;
};
```

New state fields in `CanvasState`:
- `mindMapNodes: MindMapNodeState[]`
- `mindMapEdges: MindMapEdgeState[]`

New actions in `CanvasActions`:
- `addMindMapNode(node: MindMapNodeState, edge?: MindMapEdgeState)` — appends node and optional edge, sets isDirty
- `updateMindMapNode(id: string, updates: Partial<MindMapNodeState>)` — updates node by ID, sets isDirty
- `deleteMindMapNode(id: string)` — removes node, all descendant nodes (via BFS/DFS on edges), and related edges, sets isDirty
- `setMindMapState(nodes: MindMapNodeState[], edges: MindMapEdgeState[])` — bulk set for loading from DB, does NOT set isDirty

Add `mindMapNodes` and `mindMapEdges` to temporal `partialize` for undo/redo support.

Initialize `mindMapNodes: []` and `mindMapEdges: []` in `createCanvasStore`.

`deleteMindMapNode` cascade logic:
1. Collect all descendant IDs via BFS: start from target node, follow edges where source matches current set
2. Add target node ID to removal set
3. Filter out all nodes whose ID is in removal set
4. Filter out all edges where source OR target is in removal set
  </action>
  <verify>
Run `npm ls dagre` — package installed.
Run `npx tsc --noEmit` — zero errors.
Grep `src/lib/canvas/mind-map-layout.ts` for: dagre, getLayoutedElements, NODE_WIDTH, ranksep.
Grep `src/stores/canvas-store.ts` for: MindMapNodeState, MindMapEdgeState, addMindMapNode, deleteMindMapNode, mindMapNodes, mindMapEdges.
  </verify>
  <done>
dagre layout utility calculates tree positions with 120px rank separation and 100px node separation. Canvas store manages mind map nodes/edges with cascading delete and undo/redo support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build MindMapCanvas component with full CRUD</name>
  <files>
    src/components/workshop/mind-map-canvas.tsx
  </files>
  <action>
Create the MindMapCanvas component that wires MindMapNode, MindMapEdge, dagre layout, and canvas store together:

**Props:** `workshopId: string`, `stepId: string`, `hmwStatement?: string`

**Imports:**
- ReactFlow, Background, Controls, MiniMap from `@xyflow/react`
- MindMapNode from `@/components/canvas/mind-map-node`
- MindMapEdge from `@/components/canvas/mind-map-edge`
- getLayoutedElements from `@/lib/canvas/mind-map-layout`
- useCanvasStore from store provider
- THEME_COLORS, ROOT_COLOR, getThemeColorForNode from mind-map-theme-colors
- `@xyflow/react/dist/style.css` import for ReactFlow styles

**Node/edge types registration:**
```typescript
const nodeTypes = { mindMapNode: MindMapNode };
const edgeTypes = { mindMapEdge: MindMapEdge };
```
Define OUTSIDE component to prevent re-renders.

**Store selectors:**
Subscribe to: mindMapNodes, mindMapEdges, addMindMapNode, updateMindMapNode, deleteMindMapNode, setMindMapState

**Initialization:**
- useEffect on mount: if mindMapNodes is empty AND hmwStatement exists, create root node:
  ```typescript
  const rootNode: MindMapNodeState = {
    id: 'root',
    label: hmwStatement || 'How might we...?',
    themeColorId: 'gray',
    themeColor: ROOT_COLOR.color,
    themeBgColor: ROOT_COLOR.bgColor,
    isRoot: true,
    level: 0,
  };
  setMindMapState([rootNode], []);
  ```

**Convert store state to ReactFlow nodes:**
useMemo that maps `mindMapNodes` to ReactFlow `Node[]`:
- Each node: `{ id, type: 'mindMapNode', position: { x: 0, y: 0 }, data: { ...nodeState, onLabelChange, onAddChild, onDelete } }`
- Pass callback refs for onLabelChange, onAddChild, onDelete

**Convert store state to ReactFlow edges:**
useMemo that maps `mindMapEdges` to ReactFlow `Edge[]`:
- Each edge: `{ id, source, target, type: 'mindMapEdge', data: { themeColor } }`

**Layout calculation:**
useMemo depending on rfNodes and rfEdges (structural deps only):
- Call `getLayoutedElements(rfNodes, rfEdges, { direction: 'LR' })`
- Return layoutedNodes (with updated positions)

**Callbacks:**

`handleLabelChange(nodeId: string, newLabel: string)`:
- Call `updateMindMapNode(nodeId, { label: newLabel })`
- Do NOT trigger layout recalculation (label is not a structural change per research pitfall #1)

`handleAddChild(parentId: string)`:
- Find parent node in mindMapNodes
- Calculate child level: `parentLevel + 1`
- If level >= 3, show soft warning (but still allow — per research recommendation)
- Determine theme color:
  - If parent is root: assign from THEME_COLORS based on count of existing level-1 children
  - If parent is not root: inherit parent's themeColorId
- Create new MindMapNodeState with unique ID (crypto.randomUUID()), empty label, calculated level, parentId
- Create new MindMapEdgeState with `id: parentId-newNodeId`, source: parentId, target: newNodeId
- Call `addMindMapNode(newNode, newEdge)`

`handleDelete(nodeId: string)`:
- If node isRoot, do nothing (cannot delete root)
- Count descendants via edge traversal (BFS)
- If descendants > 0, show window.confirm: "Delete this node and {N} child node(s)?"
- If confirmed (or no descendants), call `deleteMindMapNode(nodeId)`

**Render:**
```tsx
<div className="h-full w-full">
  <ReactFlow
    nodes={layoutedNodes}
    edges={rfEdges}
    nodeTypes={nodeTypes}
    edgeTypes={edgeTypes}
    fitView
    fitViewOptions={{ padding: 0.3 }}
    minZoom={0.2}
    maxZoom={2}
    proOptions={{ hideAttribution: true }}
    nodesDraggable={false}  // dagre controls positions
    nodesConnectable={false}  // no manual edge creation
    edgesFocusable={false}
    selectNodesOnDrag={false}
  >
    <Background color="#e5e7eb" gap={20} />
    <Controls showInteractive={false} />
    <MiniMap
      nodeStrokeColor={(n) => n.data?.themeColor || '#6b7280'}
      nodeColor={(n) => n.data?.themeBgColor || '#f3f4f6'}
      maskColor="rgba(0,0,0,0.1)"
    />
  </ReactFlow>
</div>
```

Key: `nodesDraggable={false}` because dagre manages all positioning. Users interact via the node action buttons, not by dragging.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors.
Run `npm run build` — production build succeeds.
Grep `src/components/workshop/mind-map-canvas.tsx` for: MindMapCanvas, getLayoutedElements, useCanvasStore, nodeTypes, edgeTypes, handleAddChild, handleDelete, handleLabelChange, fitView.
  </verify>
  <done>
MindMapCanvas renders mind map with HMW as root, supports adding children (auto-themed), inline label editing (no layout thrashing), cascading delete with confirmation, and dagre auto-layout. All state backed by canvas store with undo/redo.
  </done>
</task>

</tasks>

<verification>
1. `npm ls dagre` confirms dagre installed
2. `npx tsc --noEmit` passes with zero errors
3. `npm run build` succeeds
4. MindMapCanvas creates root node from HMW statement on init
5. dagre layout runs on structural changes (add/delete) but not label edits
6. Canvas store has mindMapNodes/mindMapEdges in temporal partialize
7. Delete cascades to descendants with confirmation dialog
8. Theme colors auto-assign to level-1 branches
</verification>

<success_criteria>
- Mind map displays HMW as central node with dagre-computed tree layout
- Users can add child nodes (up to 3+ levels) with auto-theme coloring
- Users can edit labels inline without layout thrashing
- Users can delete nodes with cascade confirmation
- All mind map state persists in canvas store with undo/redo
- dagre produces non-overlapping layout with 120px rank / 100px node separation
</success_criteria>

<output>
After completion, create `.planning/phases/28-mind-map-crazy-8s/28-02-SUMMARY.md`
</output>
