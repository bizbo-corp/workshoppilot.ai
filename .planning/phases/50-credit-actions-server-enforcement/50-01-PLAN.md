---
phase: 50-credit-actions-server-enforcement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/actions/billing-actions.ts
requirements: [CRED-02, CRED-03, PAYW-06]
autonomous: true
must_haves:
  truths:
    - "consumeCredit(workshopId) atomically decrements user.creditBalance by 1 and returns { status: 'consumed', newBalance } — two concurrent calls with balance=1 produce exactly one success and one insufficient_credits"
    - "consumeCredit returns { status: 'already_unlocked' } if workshop.creditConsumedAt is already set — idempotent"
    - "consumeCredit returns { status: 'grandfathered' } if workshop.createdAt < PAYWALL_CUTOFF_DATE — no credit deducted"
    - "consumeCredit returns { status: 'paywall_disabled' } when PAYWALL_ENABLED=false — dev/demo toggle"
    - "getCredits() returns the integer creditBalance for the authenticated user"
    - "markOnboardingComplete() sets users.onboardingComplete to true for the authenticated user"
    - "All three functions verify auth via Clerk auth() and return safe defaults for unauthenticated calls"
  artifacts:
    - path: src/actions/billing-actions.ts
      provides: "consumeCredit(), getCredits(), markOnboardingComplete() server actions"
      exports: ["consumeCredit", "getCredits", "markOnboardingComplete", "ConsumeCreditResult"]
  key_links:
    - from: src/actions/billing-actions.ts
      to: src/db/schema
      via: "Drizzle ORM conditional-UPDATE for atomic credit deduction"
      pattern: "db.update(users).set.*creditBalance.*WHERE.*gt.*creditBalance.*0.*RETURNING"
    - from: src/actions/billing-actions.ts
      to: src/db/schema/credit-transactions.ts
      via: "Insert consumption transaction row with amount=-1"
      pattern: "db.insert(creditTransactions).values"
---

# Plan 50-01: Billing Server Actions

<objective>
Create `billing-actions.ts` with atomic credit consumption, credit balance query, and onboarding completion server actions.
Purpose: Foundation for all paywall enforcement — Plan 50-02 imports these server actions to gate step advancement and Server Component rendering.
Output: `src/actions/billing-actions.ts` with `consumeCredit()`, `getCredits()`, `markOnboardingComplete()` exported.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-credit-actions-server-enforcement/50-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From src/db/schema/users.ts:
```typescript
export const users = pgTable('users', {
  id: text('id').primaryKey().$defaultFn(() => createPrefixedId('usr')),
  clerkUserId: text('clerk_user_id').notNull().unique(),
  creditBalance: integer('credit_balance').notNull().default(0),
  onboardingComplete: boolean('onboarding_complete').notNull().default(false),
  // ... other fields
});
```

From src/db/schema/workshops.ts:
```typescript
export const workshops = pgTable('workshops', {
  id: text('id').primaryKey().$defaultFn(() => createPrefixedId('ws')),
  clerkUserId: text('clerk_user_id').notNull(),
  createdAt: timestamp('created_at', { mode: 'date', precision: 3 }).notNull().defaultNow(),
  deletedAt: timestamp('deleted_at', { mode: 'date', precision: 3 }),
  creditConsumedAt: timestamp('credit_consumed_at', { mode: 'date', precision: 3 }),
  // ... other fields
});
```

From src/db/schema/credit-transactions.ts:
```typescript
export const creditTransactions = pgTable('credit_transactions', {
  id: text('id').primaryKey().$defaultFn(() => createPrefixedId('ctx')),
  clerkUserId: text('clerk_user_id').notNull(),
  type: text('type', { enum: ['purchase', 'consumption', 'refund'] }).notNull(),
  status: text('status', { enum: ['pending', 'completed', 'failed'] }).notNull().default('pending'),
  amount: integer('amount').notNull(),        // Signed: +N for purchase, -N for consumption
  balanceAfter: integer('balance_after').notNull(),
  description: text('description').notNull(),
  workshopId: text('workshop_id').references(() => workshops.id, { onDelete: 'set null' }),
  stripeSessionId: text('stripe_session_id').unique(),
  createdAt: timestamp('created_at', { mode: 'date', precision: 3 }).notNull().defaultNow(),
});
```

From src/lib/ids.ts:
```typescript
export function createPrefixedId(prefix: string): string;  // prefix_cuid2 format
```

From src/db/client.ts:
```typescript
export const db: NeonDatabase;  // neon-http driver — NO interactive transactions, NO SELECT FOR UPDATE
```

From @clerk/nextjs/server:
```typescript
export function auth(): Promise<{ userId: string | null }>;
```

Precedent pattern from src/lib/billing/fulfill-credit-purchase.ts:
```typescript
// Atomic increment using sql template — proven pattern for neon-http:
const [updatedUser] = await db
  .update(users)
  .set({ creditBalance: sql`${users.creditBalance} + ${creditQty}` })
  .where(eq(users.clerkUserId, clerkUserId))
  .returning({ creditBalance: users.creditBalance });
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create billing-actions.ts with consumeCredit(), getCredits(), markOnboardingComplete()</name>
  <files>src/actions/billing-actions.ts</files>
  <action>
Create `src/actions/billing-actions.ts` with `'use server'` directive. Implement three server actions:

**1. `consumeCredit(workshopId: string): Promise<ConsumeCreditResult>`**

Export the `ConsumeCreditResult` discriminated union type:
```typescript
export type ConsumeCreditResult =
  | { status: 'consumed'; newBalance: number }
  | { status: 'insufficient_credits' }
  | { status: 'already_unlocked' }
  | { status: 'grandfathered' }
  | { status: 'paywall_disabled' }
  | { status: 'error'; message: string };
```

Implementation steps in order:
1. **PAYWALL_ENABLED check:** If `process.env.PAYWALL_ENABLED === 'false'`, return `{ status: 'paywall_disabled' }`.
2. **Auth:** Call `auth()` from `@clerk/nextjs/server`. If no `userId`, return `{ status: 'error', message: 'Authentication required' }`.
3. **Fetch workshop with ownership check:** Use `db.query.workshops.findFirst()` with `where: and(eq(workshops.id, workshopId), eq(workshops.clerkUserId, userId), isNull(workshops.deletedAt))`. Select columns: `id`, `creditConsumedAt`, `createdAt`, `clerkUserId`. If not found, return `{ status: 'error', message: 'Workshop not found' }`.
4. **Already unlocked check (idempotent):** If `workshop.creditConsumedAt !== null`, return `{ status: 'already_unlocked' }`.
5. **Grandfathering check:** Define `PAYWALL_CUTOFF_DATE = new Date(1740614400000)` (this is the migration 0008 timestamp — all workshops created before this predate the paywall). If `workshop.createdAt < PAYWALL_CUTOFF_DATE`, return `{ status: 'grandfathered' }`.

   **IMPORTANT about the cutoff timestamp:** The migration journal entry `0008_shocking_sphinx.sql` has `"when": 1772051653843`. Use that exact value: `new Date(1772051653843)`. This is `2026-02-26T23:54:13.843Z`.

6. **Atomic conditional-UPDATE (core credit deduction):**
```typescript
const [updated] = await db
  .update(users)
  .set({ creditBalance: sql`${users.creditBalance} - 1` })
  .where(
    and(
      eq(users.clerkUserId, userId),
      gt(users.creditBalance, 0)
    )
  )
  .returning({ newBalance: users.creditBalance });
```
If `!updated` (zero rows affected), return `{ status: 'insufficient_credits' }`.

7. **Record consumption + mark workshop unlocked:** Use `Promise.all` to run two writes in parallel:
   - `db.insert(creditTransactions).values({ id: createPrefixedId('ctx'), clerkUserId: userId, type: 'consumption', status: 'completed', amount: -1, balanceAfter: updated.newBalance, description: 'Workshop unlock: Steps 7-10', workshopId })`
   - `db.update(workshops).set({ creditConsumedAt: new Date() }).where(eq(workshops.id, workshopId))`

   Wrap in try/catch — if either write fails after credit deduction, log the error with `console.error` including workshopId and userId for manual reconciliation. Still return the consumed result since the credit was already deducted.

8. Return `{ status: 'consumed', newBalance: updated.newBalance }`.

**2. `getCredits(): Promise<number>`**
- Call `auth()`. If no `userId`, return `0`.
- Query `db.query.users.findFirst({ where: eq(users.clerkUserId, userId), columns: { creditBalance: true } })`.
- Return `user?.creditBalance ?? 0`.

**3. `markOnboardingComplete(): Promise<void>`**
- Call `auth()`. If no `userId`, return early.
- `db.update(users).set({ onboardingComplete: true }).where(eq(users.clerkUserId, userId))`.

**Imports needed:**
- `import { auth } from '@clerk/nextjs/server'`
- `import { db } from '@/db/client'`
- `import { users, workshops, creditTransactions } from '@/db/schema'`
- `import { eq, gt, and, isNull, sql } from 'drizzle-orm'`
- `import { createPrefixedId } from '@/lib/ids'`

**Export the PAYWALL_CUTOFF_DATE constant** so Plan 50-02 can import it for the Server Component check:
```typescript
export const PAYWALL_CUTOFF_DATE = new Date(1772051653843);
```
  </action>
  <verify>
1. `npx tsc --noEmit` — no type errors in billing-actions.ts
2. Verify file starts with `'use server'` directive
3. Verify `consumeCredit` exports the `ConsumeCreditResult` type
4. Verify `PAYWALL_CUTOFF_DATE` is exported
5. Grep for `gt(users.creditBalance, 0)` — confirms conditional-UPDATE pattern (not read-then-write)
6. Grep for `eq(workshops.clerkUserId, userId)` — confirms ownership check
7. Grep for `PAYWALL_ENABLED` — confirms env var toggle
  </verify>
  <done>
billing-actions.ts exists with all three server actions. consumeCredit uses atomic conditional-UPDATE pattern (WHERE credit_balance > 0 RETURNING), checks ownership, handles grandfathering with exported PAYWALL_CUTOFF_DATE constant, records credit_transaction, and marks workshop.creditConsumedAt. getCredits returns integer balance. markOnboardingComplete sets flag. All functions check auth via Clerk.
  </done>
</task>

<task type="auto">
  <name>Task 2: TypeScript compilation and import verification</name>
  <files>src/actions/billing-actions.ts</files>
  <action>
Run full TypeScript compilation to ensure billing-actions.ts integrates correctly with the existing codebase:

1. Run `npx tsc --noEmit` and fix any type errors.

2. Verify the consumeCredit return type matches the exported ConsumeCreditResult union — all six status variants must be reachable from the code paths.

3. Verify that the `gt` import from `drizzle-orm` is used correctly (it takes a column and a value, not a SQL expression). The correct usage is:
```typescript
gt(users.creditBalance, 0)
```

4. Verify the `sql` template tag is used correctly for the decrement:
```typescript
sql`${users.creditBalance} - 1`
```
This follows the same pattern as `fulfill-credit-purchase.ts` which uses `sql`\`${users.creditBalance} + ${creditQty}\``.

5. Ensure no circular imports — billing-actions.ts imports from schema and client, not from other actions files.
  </action>
  <verify>
`npx tsc --noEmit` exits with code 0 — zero type errors across entire project.
  </verify>
  <done>
billing-actions.ts compiles cleanly. All types resolve. No circular imports. Ready for Plan 50-02 to import consumeCredit and PAYWALL_CUTOFF_DATE.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — zero type errors
2. `src/actions/billing-actions.ts` exists and starts with `'use server'`
3. Exports: `consumeCredit`, `getCredits`, `markOnboardingComplete`, `ConsumeCreditResult`, `PAYWALL_CUTOFF_DATE`
4. `consumeCredit` uses conditional-UPDATE pattern (no SELECT FOR UPDATE, no read-then-write)
5. Ownership check: `eq(workshops.clerkUserId, userId)` present in consumeCredit
6. PAYWALL_ENABLED env var check present in consumeCredit
7. Grandfathering: `workshop.createdAt < PAYWALL_CUTOFF_DATE` present
8. Transaction ledger: `db.insert(creditTransactions)` with `type: 'consumption'`, `amount: -1` present
9. Workshop unlock: `db.update(workshops).set({ creditConsumedAt: new Date() })` present
</verification>

<success_criteria>
- billing-actions.ts compiles without errors
- All three server actions are exported and callable
- consumeCredit uses the atomic conditional-UPDATE pattern for credit deduction
- PAYWALL_CUTOFF_DATE is exported for reuse in Plan 50-02
- ConsumeCreditResult discriminated union is exported for type-safe consumption
</success_criteria>

<output>
After completion, create `.planning/phases/50-credit-actions-server-enforcement/50-01-SUMMARY.md`
</output>
