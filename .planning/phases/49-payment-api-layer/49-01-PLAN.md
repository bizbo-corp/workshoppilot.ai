---
phase: 49-payment-api-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/billing/price-config.ts
  - src/app/api/billing/checkout/route.ts
autonomous: false
requirements: [BILL-01, BILL-02]

user_setup:
  - service: stripe
    why: "Price IDs required for Checkout Session creation"
    env_vars:
      - name: STRIPE_PRICE_SINGLE_FLIGHT
        source: "Stripe Dashboard (Test mode) -> Products -> Single Flight Workshop -> Pricing section -> copy Price ID (price_...)"
      - name: STRIPE_PRICE_SERIAL_ENTREPRENEUR
        source: "Stripe Dashboard (Test mode) -> Products -> Serial Entrepreneur Pack -> Pricing section -> copy Price ID (price_...)"
    dashboard_config:
      - task: "Update .env.local with price_ IDs (currently set to prod_ IDs)"
        location: "Stripe Dashboard -> Products -> each product -> Pricing section"

must_haves:
  truths:
    - "POSTing a valid priceId to /api/billing/checkout redirects (303) to a Stripe-hosted checkout page"
    - "POSTing an invalid priceId returns 400 with error message"
    - "Unauthenticated requests return 401"
    - "Server-side map resolves priceId to creditQty — client never supplies credit quantity"
    - "Stripe Customer is lazily created on first checkout and reused on subsequent checkouts"
  artifacts:
    - path: "src/lib/billing/price-config.ts"
      provides: "Server-side priceId-to-creditQty map with getPriceConfig() function"
      exports: ["PriceConfig", "getPriceConfig"]
    - path: "src/app/api/billing/checkout/route.ts"
      provides: "POST route handler creating Stripe Checkout Session with 303 redirect"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/billing/checkout/route.ts"
      to: "src/lib/billing/price-config.ts"
      via: "getPriceConfig(priceId) lookup"
      pattern: "getPriceConfig"
    - from: "src/app/api/billing/checkout/route.ts"
      to: "src/lib/billing/stripe.ts"
      via: "stripe.checkout.sessions.create()"
      pattern: "stripe\\.checkout\\.sessions\\.create"
    - from: "src/app/api/billing/checkout/route.ts"
      to: "src/db/schema/users.ts"
      via: "Lazy Stripe Customer creation — read stripeCustomerId, create if null, persist"
      pattern: "stripeCustomerId"
---

<objective>
Create the server-side price configuration map and Stripe Checkout route handler that redirects authenticated users to Stripe's hosted checkout page.

Purpose: Enable "Buy Now" buttons throughout the app to initiate a Stripe Checkout session for Single Flight ($79 / 1 credit) or Serial Entrepreneur ($149 / 3 credits) with server-side price validation and lazy Stripe Customer creation.

Output: `src/lib/billing/price-config.ts` (server-only price map) and `src/app/api/billing/checkout/route.ts` (POST handler returning 303 redirect to Stripe Checkout).
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-payment-api-layer/49-RESEARCH.md
@.planning/phases/48-stripe-infrastructure/48-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/billing/stripe.ts:
```typescript
import 'server-only';
import Stripe from 'stripe';
export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: '2026-02-25.clover',
  typescript: true,
});
```

From src/db/schema/users.ts (relevant columns):
```typescript
export const users = pgTable('users', {
  id: text('id').primaryKey().$defaultFn(() => createPrefixedId('usr')),
  clerkUserId: text('clerk_user_id').notNull().unique(),
  email: text('email').notNull(),
  creditBalance: integer('credit_balance').notNull().default(0),
  stripeCustomerId: text('stripe_customer_id'),
  // ... other columns
});
```

From src/db/client.ts:
```typescript
import { drizzle } from 'drizzle-orm/neon-http';
export const db = drizzle(sql, { schema });
```

Auth pattern (used throughout codebase):
```typescript
import { auth } from '@clerk/nextjs/server';
const { userId } = await auth();
```
</interfaces>
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 0: Update STRIPE_PRICE env vars from product IDs to price IDs</name>
  <action>
The STRIPE_PRICE_SINGLE_FLIGHT and STRIPE_PRICE_SERIAL_ENTREPRENEUR env vars are currently set to Stripe Product IDs (`prod_...`) instead of Price IDs (`price_...`). The checkout route requires Price IDs to create a Checkout Session.

Steps:
1. Go to https://dashboard.stripe.com (ensure Test mode is active)
2. Navigate to Products -> "Single Flight Workshop"
3. Under the Pricing section, find and copy the Price ID (format: `price_...`)
4. Navigate to Products -> "Serial Entrepreneur Pack"
5. Under the Pricing section, find and copy the Price ID (format: `price_...`)
6. Update `.env.local`:
   ```
   STRIPE_PRICE_SINGLE_FLIGHT=price_XXXXXXXXXX
   STRIPE_PRICE_SERIAL_ENTREPRENEUR=price_XXXXXXXXXX
   ```
7. Also update these values in Vercel Dashboard -> Project Settings -> Environment Variables

Without this change, `stripe.checkout.sessions.create()` will throw: `No such price: 'prod_...'`
  </action>
  <verify>
    <automated>grep -q "^STRIPE_PRICE_SINGLE_FLIGHT=price_" .env.local && grep -q "^STRIPE_PRICE_SERIAL_ENTREPRENEUR=price_" .env.local && echo "PASS: Both env vars are price_ IDs" || echo "FAIL: Env vars still contain prod_ IDs"</automated>
  </verify>
  <done>Both STRIPE_PRICE_SINGLE_FLIGHT and STRIPE_PRICE_SERIAL_ENTREPRENEUR in .env.local start with `price_` (not `prod_`)</done>
</task>

<task type="auto">
  <name>Task 1: Create server-side price configuration map and Stripe Checkout route handler</name>
  <files>
    src/lib/billing/price-config.ts
    src/app/api/billing/checkout/route.ts
  </files>
  <action>
**File 1: `src/lib/billing/price-config.ts`**

Create a server-only module that maps Stripe Price IDs to credit quantities. This is the single source of truth for what each price grants — the client never supplies a credit quantity.

```typescript
import 'server-only';

export interface PriceConfig {
  priceId: string;
  creditQty: number;
  label: string;
  amountCents: number;
}

export function getPriceConfig(priceId: string): PriceConfig | null {
  const configs: Record<string, PriceConfig> = {
    [process.env.STRIPE_PRICE_SINGLE_FLIGHT!]: {
      priceId: process.env.STRIPE_PRICE_SINGLE_FLIGHT!,
      creditQty: 1,
      label: 'Single Flight Workshop',
      amountCents: 7900,
    },
    [process.env.STRIPE_PRICE_SERIAL_ENTREPRENEUR!]: {
      priceId: process.env.STRIPE_PRICE_SERIAL_ENTREPRENEUR!,
      creditQty: 3,
      label: 'Serial Entrepreneur Pack',
      amountCents: 14900,
    },
  };
  return configs[priceId] ?? null;
}
```

Key points:
- `import 'server-only'` prevents accidental import in Client Components (same pattern as stripe.ts)
- Config is built from env vars at call time (not module init) — allows hot reload in dev
- Returns `null` for unknown price IDs — caller handles the 400 response

**File 2: `src/app/api/billing/checkout/route.ts`**

Create a POST route handler that:
1. Authenticates via `auth()` from `@clerk/nextjs/server` — return 401 if not authenticated
2. Reads `{ priceId }` from request body via `req.json()`
3. Validates priceId against `getPriceConfig()` — return 400 if invalid
4. Looks up user from DB via `db.query.users.findFirst({ where: eq(users.clerkUserId, userId) })`
5. Lazily creates a Stripe Customer if `user.stripeCustomerId` is null:
   - `stripe.customers.create({ metadata: { clerkUserId: userId }, email: user?.email })`
   - Persist `stripeCustomerId` via `db.update(users).set({ stripeCustomerId }).where(eq(users.clerkUserId, userId))`
6. Creates Checkout Session:
   ```typescript
   const session = await stripe.checkout.sessions.create({
     customer: stripeCustomerId,
     mode: 'payment',
     line_items: [{ price: priceConfig.priceId, quantity: 1 }],
     success_url: `${origin}/purchase/success?session_id={CHECKOUT_SESSION_ID}`,
     cancel_url: `${origin}/purchase/cancel`,
     metadata: {
       clerkUserId: userId,
       creditQty: String(priceConfig.creditQty),
       productType: priceConfig.label,
     },
   });
   ```
7. Returns `NextResponse.redirect(session.url!, 303)` — 303 is correct for POST->GET redirect

Imports needed:
- `auth` from `@clerk/nextjs/server`
- `headers` from `next/headers` (for `origin`)
- `NextResponse` from `next/server`
- `stripe` from `@/lib/billing/stripe`
- `getPriceConfig` from `@/lib/billing/price-config`
- `db` from `@/db/client`
- `users` from `@/db/schema`
- `eq` from `drizzle-orm`

Get origin from headers: `const origin = (await headers()).get('origin') ?? 'https://workshoppilot.ai';`

IMPORTANT: The `{CHECKOUT_SESSION_ID}` in success_url is a Stripe template variable — Stripe replaces it with the actual session ID when redirecting. Do NOT use JavaScript template interpolation for this value.

IMPORTANT: Do NOT use `redirect()` from `next/navigation` — it throws internally. Use `NextResponse.redirect()` in route handlers.
  </action>
  <verify>
    <automated>test -f src/lib/billing/price-config.ts && test -f src/app/api/billing/checkout/route.ts && grep -q "getPriceConfig" src/app/api/billing/checkout/route.ts && grep -q "server-only" src/lib/billing/price-config.ts && grep -q "303" src/app/api/billing/checkout/route.ts && grep -q "stripe.checkout.sessions.create" src/app/api/billing/checkout/route.ts && grep -q "stripe.customers.create" src/app/api/billing/checkout/route.ts && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>
    - `src/lib/billing/price-config.ts` exists with `getPriceConfig()` exported and `import 'server-only'`
    - `src/app/api/billing/checkout/route.ts` exists with POST handler that validates priceId, creates Stripe Customer lazily, creates Checkout Session, and returns 303 redirect
    - Unauthenticated requests return 401
    - Invalid priceId returns 400
    - Metadata includes clerkUserId, creditQty (string), and productType
  </done>
</task>

</tasks>

<verification>
1. `src/lib/billing/price-config.ts` exists with `import 'server-only'` guard and exports `getPriceConfig` and `PriceConfig`
2. `src/app/api/billing/checkout/route.ts` exists with `POST` export
3. Checkout route uses `auth()` for authentication and returns 401 for unauthenticated requests
4. Checkout route validates priceId against server-side map (not trusting client creditQty)
5. Checkout route creates Stripe Customer lazily (checks `stripeCustomerId` first, creates if null)
6. Checkout Session metadata includes `clerkUserId`, `creditQty`, and `productType`
7. Route returns 303 redirect to `session.url` (not 302)
8. STRIPE_PRICE_* env vars in `.env.local` are `price_` IDs (not `prod_`)
</verification>

<success_criteria>
- POSTing `{ priceId: STRIPE_PRICE_SINGLE_FLIGHT }` to `/api/billing/checkout` as an authenticated user creates a Stripe Checkout Session and returns a 303 redirect to Stripe's hosted checkout page
- POSTing an unknown priceId returns 400
- Unauthenticated POST returns 401
- First-time users get a Stripe Customer created and persisted; repeat users reuse existing customer
</success_criteria>

<output>
After completion, create `.planning/phases/49-payment-api-layer/49-01-SUMMARY.md`
</output>
