---
phase: 49-payment-api-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/billing/fulfill-credit-purchase.ts
  - src/app/api/webhooks/stripe/route.ts
autonomous: true
requirements: [BILL-04, BILL-05]

must_haves:
  truths:
    - "Webhook handler returns 200 for valid checkout.session.completed events and credits are recorded"
    - "Webhook handler returns 400 for invalid signatures — not 500"
    - "Webhook handler returns 200 for unhandled event types (not 400)"
    - "Calling fulfillCreditPurchase twice with the same sessionId results in one credit_transactions row — the second call returns already_fulfilled"
    - "A credit_transactions row is written for every successful purchase with stripeSessionId, type=purchase, amount, and balanceAfter"
    - "users.creditBalance is atomically incremented by the correct creditQty"
  artifacts:
    - path: "src/lib/billing/fulfill-credit-purchase.ts"
      provides: "Shared idempotent fulfillment function called by both webhook and success page"
      exports: ["fulfillCreditPurchase", "FulfillResult"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler with HMAC signature verification"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/billing/fulfill-credit-purchase.ts"
      via: "fulfillCreditPurchase(session.id) call on checkout.session.completed"
      pattern: "fulfillCreditPurchase"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/billing/stripe.ts"
      via: "stripe.webhooks.constructEvent() for HMAC verification"
      pattern: "stripe\\.webhooks\\.constructEvent"
    - from: "src/lib/billing/fulfill-credit-purchase.ts"
      to: "src/db/schema/credit-transactions.ts"
      via: "onConflictDoNothing on stripeSessionId UNIQUE constraint"
      pattern: "onConflictDoNothing"
    - from: "src/lib/billing/fulfill-credit-purchase.ts"
      to: "src/db/schema/users.ts"
      via: "Atomic creditBalance increment via sql template"
      pattern: "creditBalance.*sql"
---

<objective>
Create the shared idempotent credit fulfillment function and the Stripe webhook handler that processes checkout.session.completed events.

Purpose: Ensure every successful Stripe payment results in exactly one credit_transactions row and one atomic creditBalance increment, regardless of how many times the fulfillment function is called (webhook retries, concurrent success page + webhook, etc.).

Output: `src/lib/billing/fulfill-credit-purchase.ts` (shared fulfillment function) and `src/app/api/webhooks/stripe/route.ts` (webhook endpoint with HMAC signature verification).
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-payment-api-layer/49-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/billing/stripe.ts:
```typescript
import 'server-only';
import Stripe from 'stripe';
export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: '2026-02-25.clover',
  typescript: true,
});
```

From src/db/schema/credit-transactions.ts:
```typescript
export const creditTransactions = pgTable('credit_transactions', {
  id: text('id').primaryKey().$defaultFn(() => createPrefixedId('ctx')),
  clerkUserId: text('clerk_user_id').notNull(),
  type: text('type', { enum: ['purchase', 'consumption', 'refund'] }).notNull().$type<'purchase' | 'consumption' | 'refund'>(),
  status: text('status', { enum: ['pending', 'completed', 'failed'] }).notNull().default('pending').$type<'pending' | 'completed' | 'failed'>(),
  amount: integer('amount').notNull(),
  balanceAfter: integer('balance_after').notNull(),
  description: text('description').notNull(),
  workshopId: text('workshop_id').references(() => workshops.id, { onDelete: 'set null' }),
  stripeSessionId: text('stripe_session_id').unique(),
  createdAt: timestamp('created_at', { mode: 'date', precision: 3 }).notNull().defaultNow(),
}, (table) => ({
  clerkUserIdIdx: index('credit_transactions_clerk_user_id_idx').on(table.clerkUserId),
  typeIdx: index('credit_transactions_type_idx').on(table.type),
  workshopIdIdx: index('credit_transactions_workshop_id_idx').on(table.workshopId),
}));
```

From src/db/schema/users.ts (relevant columns):
```typescript
export const users = pgTable('users', {
  clerkUserId: text('clerk_user_id').notNull().unique(),
  email: text('email').notNull(),
  creditBalance: integer('credit_balance').notNull().default(0),
  stripeCustomerId: text('stripe_customer_id'),
});
```

From src/db/client.ts:
```typescript
export const db = drizzle(sql, { schema });
```

Established webhook pattern from src/app/api/webhooks/clerk/route.ts:
```typescript
const body = await req.text();        // Raw text, NOT req.json()
const headerPayload = await headers();
// ... signature verification in try/catch
// ... event handling in switch/case with try/catch
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared idempotent fulfillCreditPurchase function</name>
  <files>src/lib/billing/fulfill-credit-purchase.ts</files>
  <action>
Create a server-only module that exports the shared fulfillment function. Both the webhook handler (this plan) and the success page (Plan 49-03) call this function. The `stripeSessionId UNIQUE` constraint on `credit_transactions` is the sole idempotency gate.

```typescript
import 'server-only';
import { stripe } from '@/lib/billing/stripe';
import { db } from '@/db/client';
import { users, creditTransactions } from '@/db/schema';
import { eq, sql } from 'drizzle-orm';
```

**Export the FulfillResult type:**
```typescript
export type FulfillResult =
  | { status: 'fulfilled'; creditQty: number; newBalance: number }
  | { status: 'already_fulfilled' }
  | { status: 'payment_not_paid' }
  | { status: 'user_not_found' };
```

**Export the fulfillCreditPurchase function:**

Function signature: `export async function fulfillCreditPurchase(sessionId: string): Promise<FulfillResult>`

Implementation steps:
1. **Retrieve session from Stripe:** `const session = await stripe.checkout.sessions.retrieve(sessionId);`
2. **Check payment_status:** If `session.payment_status !== 'paid'`, return `{ status: 'payment_not_paid' }`. This guards against deferred payment methods.
3. **Extract metadata:** `const clerkUserId = session.metadata?.clerkUserId;` and `const creditQty = parseInt(session.metadata?.creditQty ?? '0', 10);`. If either is invalid, throw an Error with the session ID.
4. **Attempt idempotent insert:** Use `db.insert(creditTransactions).values({...}).onConflictDoNothing({ target: creditTransactions.stripeSessionId }).returning({ id: creditTransactions.id })`.
   - Values: `clerkUserId`, `type: 'purchase'`, `status: 'completed'`, `amount: creditQty`, `balanceAfter: 0` (placeholder — updated after the atomic increment), `description: \`Purchase: ${session.metadata?.productType ?? 'Workshop credit'}\``, `stripeSessionId: sessionId`.
   - The `balanceAfter: 0` is a placeholder. We update it after the atomic increment.
5. **Check if insert was a no-op:** If `inserted.length === 0`, return `{ status: 'already_fulfilled' }`.
6. **Atomically increment creditBalance:**
   ```typescript
   const [updatedUser] = await db
     .update(users)
     .set({ creditBalance: sql`${users.creditBalance} + ${creditQty}` })
     .where(eq(users.clerkUserId, clerkUserId))
     .returning({ creditBalance: users.creditBalance });
   ```
   If no user found (`!updatedUser`), return `{ status: 'user_not_found' }`.
7. **Update balanceAfter in the transaction row:** Update the row we just inserted with the actual post-increment balance:
   ```typescript
   await db
     .update(creditTransactions)
     .set({ balanceAfter: updatedUser.creditBalance })
     .where(eq(creditTransactions.id, inserted[0].id));
   ```
   This avoids the race condition described in RESEARCH.md Pitfall 4 — `balanceAfter` reflects the actual post-increment value, not a pre-computed estimate.
8. **Return success:** `{ status: 'fulfilled', creditQty, newBalance: updatedUser.creditBalance }`

IMPORTANT: The two writes (insert then update+update) are NOT fully atomic, but this is safe because:
- The `onConflictDoNothing` idempotency gate prevents double-counting on retries
- If the increment fails after insert, a retry will hit `already_fulfilled` — but the credits won't be applied. This is a degenerate case that would require manual intervention (acceptable for v1.8; logged via console.error)
- The neon-http driver does NOT support interactive multi-statement transactions

Add a `console.error` if `!updatedUser` after the increment (user exists in Stripe metadata but not in DB — should not happen in practice).
  </action>
  <verify>
    <automated>test -f src/lib/billing/fulfill-credit-purchase.ts && grep -q "server-only" src/lib/billing/fulfill-credit-purchase.ts && grep -q "onConflictDoNothing" src/lib/billing/fulfill-credit-purchase.ts && grep -q "fulfillCreditPurchase" src/lib/billing/fulfill-credit-purchase.ts && grep -q "FulfillResult" src/lib/billing/fulfill-credit-purchase.ts && grep -q "payment_not_paid" src/lib/billing/fulfill-credit-purchase.ts && grep -q "already_fulfilled" src/lib/billing/fulfill-credit-purchase.ts && grep -q "creditBalance.*sql" src/lib/billing/fulfill-credit-purchase.ts && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>
    - `src/lib/billing/fulfill-credit-purchase.ts` exists with `import 'server-only'`
    - Exports `FulfillResult` type and `fulfillCreditPurchase` function
    - Retrieves session from Stripe and checks `payment_status === 'paid'`
    - Inserts credit_transactions row with `onConflictDoNothing` on stripeSessionId
    - Atomically increments `users.creditBalance` via SQL expression
    - Updates `balanceAfter` from the RETURNING result of the increment
    - Returns discriminated union: fulfilled / already_fulfilled / payment_not_paid / user_not_found
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe webhook handler with HMAC signature verification</name>
  <files>src/app/api/webhooks/stripe/route.ts</files>
  <action>
Create the webhook route handler following the same structural pattern as `src/app/api/webhooks/clerk/route.ts` (raw body via `req.text()`, header extraction, signature verification in try/catch, event handling in switch/case with outer try/catch).

```typescript
import { stripe } from '@/lib/billing/stripe';
import { headers } from 'next/headers';
import { NextResponse } from 'next/server';
import { fulfillCreditPurchase } from '@/lib/billing/fulfill-credit-purchase';
import type Stripe from 'stripe';
```

**POST handler implementation:**

1. **Read raw body:** `const body = await req.text();` — NEVER use `req.json()`. The HMAC is computed over raw bytes. Using JSON-parsed body breaks signature verification.

2. **Extract stripe-signature header:**
   ```typescript
   const headerPayload = await headers();
   const signature = headerPayload.get('stripe-signature');
   ```
   If `!signature`, return `NextResponse.json({ error: 'Missing stripe-signature header' }, { status: 400 })`.

3. **Verify signature in try/catch:**
   ```typescript
   let event: Stripe.Event;
   try {
     event = stripe.webhooks.constructEvent(
       body,
       signature,
       process.env.STRIPE_WEBHOOK_SECRET!
     );
   } catch (err) {
     console.error('Stripe webhook signature verification failed:', err);
     return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });
   }
   ```
   Return 400 (not 500) for invalid signatures. Stripe will NOT retry 4xx, which is correct — a bad signature is not transient.

4. **Handle events in try/catch:**
   ```typescript
   try {
     switch (event.type) {
       case 'checkout.session.completed': {
         const session = event.data.object as Stripe.Checkout.Session;
         const result = await fulfillCreditPurchase(session.id);
         console.log(`Stripe webhook fulfillment: session=${session.id} result=${result.status}`);
         break;
       }
       case 'checkout.session.async_payment_succeeded': {
         // Handle deferred payment methods (ACH, etc.) that complete after session
         const session = event.data.object as Stripe.Checkout.Session;
         const result = await fulfillCreditPurchase(session.id);
         console.log(`Stripe webhook async fulfillment: session=${session.id} result=${result.status}`);
         break;
       }
       default:
         // Acknowledge unhandled events — return 200, NOT 400
         break;
     }
   } catch (err) {
     console.error('Stripe webhook handler error:', err);
     // Return 500 so Stripe retries — idempotency constraint prevents double-fulfillment
     return NextResponse.json({ error: 'Internal error' }, { status: 500 });
   }
   ```

5. **Return success:** `return NextResponse.json({ received: true }, { status: 200 });`

Key design decisions:
- **400 for invalid signatures:** Stripe will NOT retry 4xx. Bad signature = invalid event, not transient.
- **500 for handler errors:** Stripe WILL retry 5xx. The `onConflictDoNothing` in fulfillCreditPurchase prevents double-fulfillment on retries.
- **200 for unhandled event types:** Stripe sends many event types; returning 400 causes needless delivery failures.
- **Both `checkout.session.completed` and `checkout.session.async_payment_succeeded`:** The former fires immediately; the latter fires for deferred payment methods. The `payment_status` check inside fulfillCreditPurchase guards against fulfilling unpaid sessions.
  </action>
  <verify>
    <automated>test -f src/app/api/webhooks/stripe/route.ts && grep -q "req.text()" src/app/api/webhooks/stripe/route.ts && grep -q "constructEvent" src/app/api/webhooks/stripe/route.ts && grep -q "fulfillCreditPurchase" src/app/api/webhooks/stripe/route.ts && grep -q "stripe-signature" src/app/api/webhooks/stripe/route.ts && grep -q "checkout.session.completed" src/app/api/webhooks/stripe/route.ts && grep -q "status: 400" src/app/api/webhooks/stripe/route.ts && grep -q "status: 200" src/app/api/webhooks/stripe/route.ts && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>
    - `src/app/api/webhooks/stripe/route.ts` exists with POST export
    - Uses `req.text()` for raw body (not `req.json()`)
    - Verifies HMAC signature via `stripe.webhooks.constructEvent()`
    - Returns 400 for invalid/missing signatures
    - Handles `checkout.session.completed` and `checkout.session.async_payment_succeeded` events
    - Calls `fulfillCreditPurchase(session.id)` for each handled event
    - Returns 200 for unhandled event types
    - Returns 500 for handler errors (Stripe retries; idempotency prevents double-fulfillment)
  </done>
</task>

</tasks>

<verification>
1. `src/lib/billing/fulfill-credit-purchase.ts` exports `fulfillCreditPurchase` and `FulfillResult`
2. `src/app/api/webhooks/stripe/route.ts` exports `POST`
3. Webhook uses `req.text()` (not `req.json()`) for raw body
4. Webhook returns 400 for missing/invalid `stripe-signature` header
5. Webhook returns 200 for unhandled event types
6. Webhook returns 500 for handler errors (enabling Stripe retry)
7. fulfillCreditPurchase checks `payment_status === 'paid'` before writing
8. fulfillCreditPurchase uses `onConflictDoNothing` on `stripeSessionId` for idempotency
9. fulfillCreditPurchase atomically increments `users.creditBalance` via `sql` template
10. `balanceAfter` in credit_transactions is set from the RETURNING result (not pre-computed)
</verification>

<success_criteria>
- Stripe webhook endpoint at `/api/webhooks/stripe` verifies signatures and processes `checkout.session.completed` events
- `fulfillCreditPurchase()` is callable by both the webhook handler and the success page (Plan 49-03) with identical behavior
- Calling `fulfillCreditPurchase()` twice with the same session ID results in exactly one credit_transactions row and one creditBalance increment
- Invalid signatures return 400; handler errors return 500; unhandled events return 200
</success_criteria>

<output>
After completion, create `.planning/phases/49-payment-api-layer/49-02-SUMMARY.md`
</output>
