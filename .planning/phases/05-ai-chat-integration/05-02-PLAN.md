---
phase: 05-ai-chat-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/components/workshop/chat-panel.tsx
  - src/components/workshop/step-container.tsx
  - src/app/workshop/[sessionId]/step/[stepId]/page.tsx
autonomous: false

must_haves:
  truths:
    - "User can type a message and send it in the chat panel"
    - "AI response streams in progressively with typing indicator visible during generation"
    - "Chat UI appears at every step with the same generic AI facilitator"
    - "Chat history persists when navigating between steps and returning"
    - "Messages are scoped per step -- Step 1 chat is separate from Step 2 chat"
  artifacts:
    - path: "src/components/workshop/chat-panel.tsx"
      provides: "Working chat UI with useChat hook"
      min_lines: 50
    - path: "src/app/workshop/[sessionId]/step/[stepId]/page.tsx"
      provides: "Step page passing initialMessages and sessionId to ChatPanel"
      contains: "loadMessages"
  key_links:
    - from: "src/components/workshop/chat-panel.tsx"
      to: "/api/chat"
      via: "useChat hook with api option"
      pattern: "useChat.*api.*api/chat"
    - from: "src/app/workshop/[sessionId]/step/[stepId]/page.tsx"
      to: "src/lib/ai/message-persistence.ts"
      via: "loadMessages call in server component"
      pattern: "loadMessages"
    - from: "src/components/workshop/chat-panel.tsx"
      to: "useChat initialMessages"
      via: "initialMessages prop passed from server component"
      pattern: "initialMessages"
    - from: "src/components/workshop/step-container.tsx"
      to: "src/components/workshop/chat-panel.tsx"
      via: "passes sessionId, stepId, initialMessages props"
      pattern: "sessionId.*stepId.*initialMessages"
---

<objective>
Wire the existing ChatPanel component to the /api/chat streaming endpoint using the useChat hook, load persisted messages from the database on navigation, and verify the complete end-to-end chat flow works at every step.

Purpose: This plan transforms the placeholder chat UI (disabled input, static greeting) into a fully functional AI chat interface. Users will be able to type messages, see streaming AI responses, and have their chat history persist across step navigation. This completes the Phase 5 requirements (CHAT-01 through CHAT-04).

Output: Working chat at every workshop step with streaming Gemini responses and persistent history.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-chat-integration/05-RESEARCH.md
@.planning/phases/05-ai-chat-integration/05-01-SUMMARY.md

# Existing code being modified
@src/components/workshop/chat-panel.tsx
@src/components/workshop/step-container.tsx
@src/app/workshop/[sessionId]/step/[stepId]/page.tsx
@src/lib/workshop/step-metadata.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire ChatPanel with useChat and update step page to pass props</name>
  <files>
    src/components/workshop/chat-panel.tsx
    src/components/workshop/step-container.tsx
    src/app/workshop/[sessionId]/step/[stepId]/page.tsx
  </files>
  <action>
1. **Update `src/app/workshop/[sessionId]/step/[stepId]/page.tsx`** (Server Component):
   - Import `loadMessages` from `@/lib/ai/message-persistence`
   - Import `getStepByOrder` from `@/lib/workshop/step-metadata` (already imported)
   - After the existing session/step validation, load chat messages:
     ```
     const step = getStepByOrder(stepNumber);  // already exists
     const initialMessages = await loadMessages(sessionId, step.id);
     ```
   - Pass `sessionId` and `initialMessages` to `StepContainer`:
     ```
     <StepContainer stepOrder={stepNumber} sessionId={sessionId} initialMessages={initialMessages} />
     ```
   - The `step.id` here is the semantic step ID (like 'empathize') which matches how chat messages are stored

2. **Update `src/components/workshop/step-container.tsx`** (Client Component):
   - Update the interface to accept new props:
     ```
     interface StepContainerProps {
       stepOrder: number;
       sessionId: string;
       initialMessages?: UIMessage[];
     }
     ```
   - Import `UIMessage` from `ai` for the type
   - Pass `sessionId` and `initialMessages` through to `ChatPanel` in both mobile and desktop layouts:
     ```
     <ChatPanel stepOrder={stepOrder} sessionId={sessionId} initialMessages={initialMessages} />
     ```

3. **Rewrite `src/components/workshop/chat-panel.tsx`** (Client Component):
   - Keep `'use client'` directive
   - Import `useChat` from `@ai-sdk/react`
   - Import `UIMessage` from `ai`
   - Import existing deps: `TextareaAutosize`, `Send` from lucide, `Button`, `cn`, `getStepByOrder`
   - Import `useRef`, `useEffect` from react

   - Update interface:
     ```
     interface ChatPanelProps {
       stepOrder: number;
       sessionId: string;
       initialMessages?: UIMessage[];
     }
     ```

   - Inside the component, get step metadata (already exists) and use it for stepId:
     ```
     const step = getStepByOrder(stepOrder);
     ```

   - Set up useChat hook:
     ```
     const { messages, input, handleInputChange, handleSubmit, isLoading, status } = useChat({
       api: '/api/chat',
       body: { sessionId, stepId: step?.id },
       initialMessages,
     });
     ```

   - Add auto-scroll to bottom when new messages arrive:
     ```
     const messagesEndRef = useRef<HTMLDivElement>(null);
     useEffect(() => {
       messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
     }, [messages]);
     ```

   - Handle Enter to send (Shift+Enter for newline):
     ```
     const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
       if (e.key === 'Enter' && !e.shiftKey) {
         e.preventDefault();
         const form = e.currentTarget.closest('form');
         if (form) form.requestSubmit();
       }
     };
     ```

   - Render messages area:
     - Map over `messages` array (from useChat, NOT hardcoded greeting)
     - For each message, render with role-based styling:
       - User messages: right-aligned or distinct styling
       - Assistant messages: left-aligned with AI avatar (keep existing "AI" circle avatar pattern)
     - Render message content by mapping over `message.parts`, filtering for `part.type === 'text'`
     - If `messages.length === 0`, show a welcome message using `step.greeting` (preserve existing behavior for empty chats)
     - After messages, render a typing indicator when `isLoading` is true: "AI is thinking..." with subtle animation (e.g., pulsing dots or text-muted-foreground)
     - Place `<div ref={messagesEndRef} />` at the end for auto-scroll target

   - Render input area:
     - Wrap in `<form onSubmit={handleSubmit}>`
     - TextareaAutosize: REMOVE `disabled` attribute, update placeholder to "Type your message..." (remove "AI facilitation coming soon...")
     - Bind `value={input}` and `onChange={handleInputChange}`
     - Keep existing styling classes on the textarea
     - Send button: REMOVE `disabled` attribute, add `disabled={isLoading || !input.trim()}` instead (disable when loading or empty input)
     - Keep existing button styling (size="icon", variant="default")

   - Keep the step-not-found fallback (if !step, render error message)

   IMPORTANT: The `body` option in useChat sends `sessionId` and `stepId` with every request. The stepId must be the semantic ID (like 'empathize') NOT the step number.

   IMPORTANT: Do NOT remove the 'use client' directive. ChatPanel is a client component because useChat requires client-side hooks.

   IMPORTANT: Preserve the existing Tailwind styling patterns (bg-muted for messages, bg-primary for avatars, border-t for input area). The goal is to activate the chat, not redesign it.
  </action>
  <verify>
    - `npm run build` completes without errors
    - Chat panel component uses useChat hook (grep for 'useChat' in chat-panel.tsx)
    - Step page loads initial messages (grep for 'loadMessages' in page.tsx)
    - Input is no longer disabled (grep for 'coming soon' should return nothing in chat-panel.tsx)
  </verify>
  <done>ChatPanel renders with useChat hook connected to /api/chat, sends sessionId and stepId with each request, displays streaming AI responses, shows typing indicator during generation, auto-scrolls on new messages, and loads persisted messages when navigating back to a step.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify end-to-end chat flow</name>
  <what-built>Complete AI chat integration: ChatPanel wired to Gemini via /api/chat with streaming responses and message persistence across step navigation.</what-built>
  <how-to-verify>
1. Start the dev server: `npm run dev`
2. Ensure GOOGLE_GENERATIVE_AI_API_KEY is set in .env.local
3. Navigate to the landing page and start a new workshop (or use existing session)
4. On Step 1 (Empathize):
   - Verify the chat panel is visible with a welcome message
   - Type "Hello, I have an idea for a fitness app" and press Enter (or click Send)
   - Verify: AI response streams in progressively (not all at once)
   - Verify: Typing indicator shows while AI is generating
   - Verify: Both your message and AI response appear in the chat
5. Send a follow-up message: "Can you help me understand my users better?"
   - Verify: Conversation continues with context
6. Navigate to Step 2 (using Next button or sidebar)
   - Verify: Step 2 has a fresh/empty chat (no Step 1 messages)
7. Navigate back to Step 1
   - Verify: Your previous conversation from Step 1 is restored (messages persist)
8. Check mobile view (resize browser to < 768px):
   - Verify: Chat panel still works in stacked layout
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with the chat flow</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. Chat input is enabled (no "coming soon" placeholder)
3. useChat hook connects to /api/chat endpoint
4. Messages stream from Gemini in real-time
5. Typing indicator visible during generation
6. Chat history persists across step navigation
7. Messages are scoped per step (Step 1 and Step 2 have separate conversations)
</verification>

<success_criteria>
- CHAT-01: Gemini API processes requests via AI SDK with streaming (verified by sending message and seeing streamed response)
- CHAT-02: Chat interface has message input, send button, and scrollable message history (verified visually)
- CHAT-03: Chat UI appears at every step with same generic AI (verified by checking multiple steps)
- CHAT-04: AI responses stream in real-time with typing indicator (verified by observing progressive display)
- BONUS: Chat history persists when navigating between steps (verified by nav test)
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-chat-integration/05-02-SUMMARY.md`
</output>
