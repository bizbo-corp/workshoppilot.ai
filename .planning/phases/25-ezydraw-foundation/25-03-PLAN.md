---
phase: 25-ezydraw-foundation
plan: 03
type: execute
wave: 3
depends_on: ["25-02"]
files_modified:
  - src/components/ezydraw/tools/pencil-tool.tsx
  - src/components/ezydraw/ezydraw-stage.tsx
autonomous: true

must_haves:
  truths:
    - "User can draw freehand strokes on the canvas with mouse or touch"
    - "Strokes have velocity-based variable width (thicker when slow, thinner when fast)"
    - "Strokes appear smooth without jagged edges or gaps"
    - "Drawing performance does not lag (transient state in refs, not React state)"
    - "Completed strokes are saved to drawing store as StrokeElement"
  artifacts:
    - path: "src/components/ezydraw/tools/pencil-tool.tsx"
      provides: "Freehand drawing tool using perfect-freehand for stroke rendering"
      contains: "PencilTool"
    - path: "src/components/ezydraw/ezydraw-stage.tsx"
      provides: "Updated stage integrating pencil tool rendering"
      contains: "PencilTool"
  key_links:
    - from: "src/components/ezydraw/tools/pencil-tool.tsx"
      to: "perfect-freehand"
      via: "getStroke() for velocity-based path generation"
      pattern: "getStroke"
    - from: "src/components/ezydraw/tools/pencil-tool.tsx"
      to: "src/stores/drawing-store.ts"
      via: "addElement to persist completed stroke"
      pattern: "addElement"
    - from: "src/components/ezydraw/ezydraw-stage.tsx"
      to: "src/components/ezydraw/tools/pencil-tool.tsx"
      via: "renders PencilTool component inside drawing layer"
      pattern: "PencilTool"
---

<objective>
Implement freehand pencil drawing with perfect-freehand library for velocity-based stroke width. This is the core drawing capability — the tool users will use most.

Purpose: Enable freehand drawing with natural, pressure-simulated strokes that feel responsive and smooth.

Output: PencilTool component handling pointer events and rendering strokes via perfect-freehand, integrated into EzyDrawStage.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/25-ezydraw-foundation/25-RESEARCH.md
@.planning/phases/25-ezydraw-foundation/25-02-SUMMARY.md
@src/components/ezydraw/ezydraw-stage.tsx
@src/stores/drawing-store.ts
@src/lib/drawing/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PencilTool with perfect-freehand integration</name>
  <files>
    src/components/ezydraw/tools/pencil-tool.tsx
  </files>
  <action>
    Create `src/components/ezydraw/tools/pencil-tool.tsx`:

    'use client' directive.

    **Imports:**
    - `getStroke` from 'perfect-freehand'
    - `Line, Group` from 'react-konva'
    - `KonvaEventObject` from 'konva/lib/Node' (type import)
    - `useDrawingStore` from drawing-store
    - Types from drawing/types

    **State management (CRITICAL for performance):**
    - Use `useRef` for transient drawing state (NOT useState — avoids 60fps re-renders):
      - `isDrawingRef = useRef(false)`
      - `currentPointsRef = useRef<number[][]>([])` — array of [x, y, pressure] tuples
      - `currentPathRef = useRef<number[]>([])` — flattened points for Konva Line display
    - Only use React state for `forceUpdate` trigger (a simple counter increment to re-render current stroke preview)

    **Pointer event handlers (on the parent Group or Stage):**
    - `handlePointerDown(e: KonvaEventObject<PointerEvent>)`:
      - Check activeTool === 'pencil', if not return
      - Get position from `e.target.getStage()?.getPointerPosition()`
      - Get pressure from `e.evt.pressure || 0.5`
      - Set isDrawingRef.current = true
      - Initialize currentPointsRef with [[x, y, pressure]]
      - Call `e.evt.preventDefault()` to prevent touch scrolling

    - `handlePointerMove(e: KonvaEventObject<PointerEvent>)`:
      - If not drawing, return
      - Get position and pressure
      - Append [x, y, pressure] to currentPointsRef
      - Generate stroke outline: call `getStroke(currentPointsRef.current, { size: strokeWidth * 4, thinning: 0.5, smoothing: 0.5, streamline: 0.5, simulatePressure: e.evt.pointerType !== 'pen' })` — simulatePressure false when using real stylus pressure
      - Convert outline points to flat SVG path data for Konva Line: flatten [[x,y],[x,y]] to [x,y,x,y]
      - Store in currentPathRef
      - Trigger forceUpdate to re-render preview

    - `handlePointerUp()`:
      - If not drawing, return
      - Generate final stroke outline from currentPointsRef
      - Create StrokeElement: `{ id: createElementId(), type: 'pencil', x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1, opacity: 1, points: flattenedPoints, stroke: strokeColor, strokeWidth: 1, fill: strokeColor }`
      - Note: perfect-freehand produces OUTLINE points (a closed shape), so the stroke renders as a filled Line (closed=true, fill=strokeColor), NOT as a stroked line. strokeWidth on the Konva Line should be 0 or 1.
      - Call addElement(strokeElement) to persist to store
      - Reset: isDrawingRef = false, currentPointsRef = [], currentPathRef = []

    **Rendering:**
    - Render a Group with pointer event handlers attached
    - Inside Group: render the current in-progress stroke as a Line with:
      - `points={currentPathRef.current}`
      - `fill={strokeColor}`
      - `closed={true}`
      - `stroke={strokeColor}`
      - `strokeWidth={1}`
      - `listening={false}` (performance: no hit detection on transient stroke)
      - `perfectDrawEnabled={false}` (performance: skip buffer canvas)
    - **Do NOT render completed strokes here** — completed strokes render from the store in the stage's element renderer (which we add in the stage update below)

    **Helper function:**
    - `getSvgPathFromStroke(stroke: number[][]): number[]` — takes perfect-freehand output [[x,y],...] and flattens to [x,y,x,y,...] for Konva Line points prop

    Export `PencilTool` component. It accepts event handlers to be wired to the Stage.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation.
    Verify perfect-freehand usage: `grep "getStroke" src/components/ezydraw/tools/pencil-tool.tsx`
    Verify ref-based state: `grep "useRef" src/components/ezydraw/tools/pencil-tool.tsx` should show at least 3 refs
  </verify>
  <done>PencilTool handles pointer events, generates velocity-based strokes via perfect-freehand with ref-based transient state, and persists completed strokes to drawing store.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate PencilTool into EzyDrawStage with element rendering</name>
  <files>
    src/components/ezydraw/ezydraw-stage.tsx
  </files>
  <action>
    Update `src/components/ezydraw/ezydraw-stage.tsx` to:

    1. **Import PencilTool** from ./tools/pencil-tool

    2. **Add element renderer:** Create a function or component `DrawingElements` that reads `elements` from useDrawingStore and renders each DrawingElement as the appropriate Konva shape:
       - StrokeElement (type='pencil'): `<Line points={el.points} fill={el.fill} stroke={el.stroke} strokeWidth={el.strokeWidth} closed={true} listening={false} perfectDrawEnabled={false} x={el.x} y={el.y} rotation={el.rotation} scaleX={el.scaleX} scaleY={el.scaleY} opacity={el.opacity} />`
       - Other element types: render placeholder for now (empty fragment). Plans 04 and 05 will add their renderers.

    3. **Wire PencilTool into drawing layer:**
       - Render PencilTool inside the drawing Layer
       - The PencilTool's pointer handlers need to be on the Stage (not just the tool's Group) to capture events anywhere on canvas
       - Approach: PencilTool renders its own Group. The Stage's `onPointerDown/Move/Up` handlers delegate to the active tool. PencilTool exposes its handlers and the stage wires them.
       - Alternative (simpler): Give the entire Stage the pointer event handlers from PencilTool when activeTool==='pencil'. This avoids event delegation complexity.
       - **Recommended approach:** Put a transparent rect (full stage size) in the drawing layer that captures all pointer events, then delegate to the active tool's handlers based on activeTool state. This rect is the "interaction layer."

    4. **Interaction rect pattern:**
       - Add a transparent `<Rect width={stageWidth} height={stageHeight} fill="transparent" />` as the FIRST child of the drawing Layer
       - Attach onPointerDown, onPointerMove, onPointerUp to this Rect
       - These handlers check `activeTool` from store and delegate to the appropriate tool handler
       - For now, only pencil is implemented; other tools will be added in plans 03-05

    5. **Remove placeholder "Draw here" text** that was added in plan 02.

    6. **Element rendering order:** Render DrawingElements AFTER the interaction rect but BEFORE the PencilTool's current-stroke preview, so the preview appears on top.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation.
    Run `npm run build` to verify no SSR errors (critical: canvas components must be dynamically imported).
    Verify PencilTool integration: `grep "PencilTool" src/components/ezydraw/ezydraw-stage.tsx`
  </verify>
  <done>EzyDrawStage renders stored elements as Konva shapes, integrates PencilTool for freehand drawing, and uses interaction rect for event capture. Users can draw freehand strokes that persist in the store.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds (no SSR errors)
3. PencilTool uses perfect-freehand getStroke for velocity-based paths
4. Transient state uses refs (not useState) for 60fps performance
5. Completed strokes render from store as filled Konva Lines
6. Stage has interaction rect for event delegation
</verification>

<success_criteria>
- User can draw freehand strokes on the canvas
- Strokes show velocity-based variable width (natural feel)
- No lag or stutter during drawing (ref-based transient state)
- Completed strokes persist in drawing store
- Build succeeds without SSR errors
</success_criteria>

<output>
After completion, create `.planning/phases/25-ezydraw-foundation/25-03-SUMMARY.md`
</output>
