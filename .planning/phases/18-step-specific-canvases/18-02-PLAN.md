---
phase: 18-step-specific-canvases
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/components/canvas/react-flow-canvas.tsx
  - src/lib/workshop/context/canvas-context.ts
autonomous: true

must_haves:
  truths:
    - "Step 2 (stakeholder-mapping) renders Power x Interest quadrant overlay on the canvas"
    - "Step 4 (sense-making) renders empathy map quadrant overlay on the canvas"
    - "Post-its dropped in Step 2 are assigned correct quadrant metadata based on center-point position"
    - "Post-its dropped in Step 4 are assigned correct quadrant metadata based on center-point position"
    - "Non-quadrant steps (e.g., challenge, user-research) render canvas without overlay"
    - "AI context for Step 2 groups stakeholders by Power-Interest quadrant"
    - "AI context for Step 4 groups insights by empathy map quadrant"
  artifacts:
    - path: "src/components/canvas/react-flow-canvas.tsx"
      provides: "QuadrantOverlay rendering conditional on step config, quadrant detection on drag end"
      contains: "QuadrantOverlay"
    - path: "src/lib/workshop/context/canvas-context.ts"
      provides: "assembleStakeholderCanvasContext and assembleEmpathyMapCanvasContext functions"
      exports: ["assembleStakeholderCanvasContext", "assembleEmpathyMapCanvasContext", "assembleCanvasContextForStep"]
  key_links:
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/lib/canvas/step-canvas-config.ts"
      via: "getStepCanvasConfig call with stepId prop"
      pattern: "getStepCanvasConfig"
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/components/canvas/quadrant-overlay.tsx"
      via: "conditional rendering inside ReactFlow"
      pattern: "QuadrantOverlay"
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/lib/canvas/quadrant-detection.ts"
      via: "detectQuadrant call in handleNodesChange"
      pattern: "detectQuadrant"
---

<objective>
Wire the quadrant overlay and detection logic into the existing ReactFlowCanvas, and create AI context assembly functions that group post-its by quadrant.

Purpose: Complete the step-specific canvas integration so Steps 2 and 4 display quadrant grids, post-its are automatically assigned to quadrants on drag, and the AI receives quadrant-grouped context.

Output: Modified ReactFlowCanvas with conditional quadrant support, and new canvas context assembly module.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-step-specific-canvases/18-RESEARCH.md
@.planning/phases/18-step-specific-canvases/18-01-SUMMARY.md

# Files modified in this plan
@src/components/canvas/react-flow-canvas.tsx
@src/lib/context/assemble-context.ts

# Files from Plan 01 (referenced)
@src/lib/canvas/step-canvas-config.ts
@src/lib/canvas/quadrant-detection.ts
@src/components/canvas/quadrant-overlay.tsx
@src/stores/canvas-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire QuadrantOverlay and quadrant detection into ReactFlowCanvas</name>
  <files>
    src/components/canvas/react-flow-canvas.tsx
  </files>
  <action>
Modify `react-flow-canvas.tsx` to add step-specific quadrant support:

**1. Add imports:**
```typescript
import { getStepCanvasConfig } from '@/lib/canvas/step-canvas-config';
import { QuadrantOverlay } from './quadrant-overlay';
import { detectQuadrant } from '@/lib/canvas/quadrant-detection';
```

**2. Get step config inside `ReactFlowCanvasInner`:**
```typescript
const stepConfig = getStepCanvasConfig(stepId);
```

**3. Modify `handleNodesChange` to detect quadrant on drag end:**

In the existing `changes.forEach` block where drag completion is handled (where `change.type === 'position' && change.dragging === false && change.position`), AFTER calculating `snappedPosition`, add quadrant detection:

```typescript
// Detect quadrant if step has quadrant layout
const quadrant = stepConfig.hasQuadrants && stepConfig.quadrantType
  ? detectQuadrant(
      snappedPosition,
      120, // post-it default width
      120, // post-it default height
      stepConfig.quadrantType
    )
  : undefined;

updatePostIt(change.id, { position: snappedPosition, quadrant });
```

This replaces the existing `updatePostIt(change.id, { position: snappedPosition })` call. For non-quadrant steps, `quadrant` will be `undefined` which is fine (optional field).

**4. Also add quadrant detection to `createPostItAtPosition`:**

After `addPostIt`, we cannot retroactively set quadrant on the just-created post-it since addPostIt generates the ID internally. Instead, modify `addPostIt` call to include quadrant:

Actually, looking at the existing code, `addPostIt` takes `Omit<PostIt, 'id'>`. So we CAN pass `quadrant` in the addPostIt call:

```typescript
const createPostItAtPosition = useCallback(
  (clientX: number, clientY: number) => {
    const flowPosition = screenToFlowPosition({ x: clientX, y: clientY });
    const snappedPosition = snapToGrid(flowPosition);

    // Detect initial quadrant
    const quadrant = stepConfig.hasQuadrants && stepConfig.quadrantType
      ? detectQuadrant(snappedPosition, 120, 120, stepConfig.quadrantType)
      : undefined;

    shouldEditLatest.current = true;
    addPostIt({
      text: '',
      position: snappedPosition,
      width: 120,
      height: 120,
      quadrant,
    });
  },
  [screenToFlowPosition, snapToGrid, addPostIt, stepConfig]
);
```

Do the same for `handleToolbarAdd` — add quadrant detection for the toolbar-created post-it position.

**5. Add `stepConfig` to dependency arrays** of callbacks that now use it: `handleNodesChange`, `createPostItAtPosition`, `handleToolbarAdd`.

**6. Render QuadrantOverlay inside ReactFlow (as a child alongside Background and Controls):**

```tsx
{stepConfig.hasQuadrants && stepConfig.quadrantConfig && (
  <QuadrantOverlay config={stepConfig.quadrantConfig} />
)}
```

Place this AFTER `<Controls>` and BEFORE the closing `</ReactFlow>` tag.

**7. Set initial viewport centering for quadrant steps:**

For steps with quadrants, the canvas center (0,0) should be visible initially. Modify the `defaultViewport` to center the origin. Since we already have `fitView={postIts.length > 0}` which auto-fits when posts exist, this only matters for empty canvas.

When there are no post-its and the step has quadrants, we want the viewport centered on (0,0). The current `defaultViewport={{ x: 0, y: 0, zoom: 1 }}` places canvas origin at the top-left of the screen. Instead, for quadrant steps with no existing post-its, we need the center of the viewport to align with canvas origin.

Simple approach: use the existing `hasFitView` effect but also handle empty quadrant canvases:

```typescript
useEffect(() => {
  if (postIts.length > 0 && !hasFitView.current) {
    setTimeout(() => {
      fitView({ padding: 0.2, duration: 300 });
      hasFitView.current = true;
    }, 100);
  }
}, [postIts.length, fitView]);
```

For empty quadrant canvases, set `fitView={false}` and use `defaultViewport` that centers the origin. Since we don't know the container dimensions at render time, use an `onInit` callback:

```typescript
const handleInit = useCallback((instance: ReactFlowInstance) => {
  if (stepConfig.hasQuadrants && postIts.length === 0) {
    // Center viewport on (0,0) for quadrant steps
    const { width, height } = instance.getViewport ?
      { width: 0, height: 0 } : { width: 0, height: 0 };
    // Use setViewport to center (0,0) in the middle of the container
    const container = document.querySelector('.react-flow');
    if (container) {
      const rect = container.getBoundingClientRect();
      instance.setViewport({
        x: rect.width / 2,
        y: rect.height / 2,
        zoom: 1,
      });
    }
  }
}, [stepConfig, postIts.length]);
```

Add `onInit={handleInit}` to ReactFlow props. Import `type ReactFlowInstance` from `@xyflow/react`.

IMPORTANT: For `fitView` prop, only set to true when `postIts.length > 0` (as currently). For quadrant steps with no post-its, `onInit` handles centering.
  </action>
  <verify>
Run `npx tsc --noEmit` — no TypeScript errors. Verify `QuadrantOverlay` appears inside ReactFlow JSX. Verify `detectQuadrant` is called in handleNodesChange. Verify `getStepCanvasConfig` is called with stepId.
  </verify>
  <done>
ReactFlowCanvas renders QuadrantOverlay for steps with quadrant config. Post-its created (double-click, toolbar) and dragged receive correct quadrant metadata. Non-quadrant steps render unchanged. Initial viewport centers on (0,0) for empty quadrant canvases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AI canvas context assembly with quadrant grouping</name>
  <files>
    src/lib/workshop/context/canvas-context.ts
  </files>
  <action>
Create `src/lib/workshop/context/canvas-context.ts` for step-specific AI context assembly.

**Imports:**
```typescript
import type { PostIt } from '@/stores/canvas-store';
import type { Quadrant } from '@/lib/canvas/quadrant-detection';
import { getQuadrantLabel } from '@/lib/canvas/quadrant-detection';
```

**1. `assembleStakeholderCanvasContext(postIts: PostIt[]): string`**

Groups post-its by Power-Interest quadrant for AI context:
- Filter out group nodes (type !== 'group' or type undefined/postIt)
- Group by `postIt.quadrant` field
- Order sections: 'high-power-high-interest', 'high-power-low-interest', 'low-power-high-interest', 'low-power-low-interest'
- Format each section as:
  ```
  **Manage Closely** (3 stakeholders):
  - Stakeholder A
  - Stakeholder B
  - Stakeholder C
  ```
- Skip empty sections (no post-its in quadrant)
- Post-its without quadrant field grouped under a "Unassigned" section at the end
- Return joined string with double newlines between sections
- Return empty string if no post-its

**2. `assembleEmpathyMapCanvasContext(postIts: PostIt[]): string`**

Groups post-its by empathy map quadrant for AI context:
- Filter out group nodes
- Group by `postIt.quadrant`
- Order sections: 'said', 'thought', 'felt', 'experienced'
- Format each section as:
  ```
  **What they said**:
  - Quote or observation
  ```
- Skip empty sections
- Post-its without quadrant field grouped under "Unassigned" section
- Return joined string or empty string

**3. `assembleCanvasContextForStep(stepId: string, postIts: PostIt[]): string`**

Dispatcher function:
- If `stepId === 'stakeholder-mapping'` → return `assembleStakeholderCanvasContext(postIts)`
- If `stepId === 'sense-making'` → return `assembleEmpathyMapCanvasContext(postIts)`
- Otherwise → return a simple flat list: `Canvas items:\n` + postIts filtered to non-groups, mapped to `- {text}`, joined with newlines
- Return empty string if no post-its (after filtering groups)

Export all three functions as named exports.

NOTE: This module creates the context strings but does NOT wire them into the existing `assembleStepContext` function in `src/lib/context/assemble-context.ts`. That wiring is Phase 19 (AI-Canvas Integration) work, per the roadmap. Phase 18 creates the assembly functions; Phase 19 calls them from the AI pipeline.
  </action>
  <verify>
Run `npx tsc --noEmit` — no TypeScript errors. Grep for `assembleStakeholderCanvasContext` and `assembleEmpathyMapCanvasContext` to confirm exports. Verify the file imports from quadrant-detection.ts correctly.
  </verify>
  <done>
Three canvas context assembly functions exist: stakeholder (groups by Power-Interest quadrant), empathy map (groups by Said/Thought/Felt/Experienced), and dispatcher (routes by stepId). All filter out group nodes, handle missing quadrant field gracefully, and produce human-readable AI context strings.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes without errors (SSR safety preserved)
3. `grep -r "QuadrantOverlay" src/components/canvas/react-flow-canvas.tsx` confirms overlay integration
4. `grep -r "detectQuadrant" src/components/canvas/react-flow-canvas.tsx` confirms detection wiring
5. `grep -r "getStepCanvasConfig" src/components/canvas/react-flow-canvas.tsx` confirms step-aware behavior
6. `grep -r "assembleStakeholderCanvasContext" src/lib/workshop/context/canvas-context.ts` confirms export
7. `grep -r "assembleEmpathyMapCanvasContext" src/lib/workshop/context/canvas-context.ts` confirms export
8. The canvas on steps other than 2 and 4 renders exactly as before (no regression)
</verification>

<success_criteria>
- Step 2 canvas displays Power x Interest quadrant grid overlay with labeled quadrants
- Step 4 canvas displays empathy map quadrant overlay with labeled quadrants
- Post-its created or dragged on quadrant steps receive correct quadrant metadata
- Non-quadrant steps render standard canvas without overlay (no regression)
- AI context functions produce quadrant-grouped text for stakeholder and empathy map steps
- TypeScript compiles without errors, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/18-step-specific-canvases/18-02-SUMMARY.md`
</output>
