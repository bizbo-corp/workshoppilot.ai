---
phase: 02-authentication-roles
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - src/app/dashboard/page.tsx
  - src/app/admin/page.tsx
  - src/components/layout/header.tsx
  - src/app/page.tsx
  - src/app/layout.tsx
  - src/lib/auth/anonymous-session.ts
  - src/app/api/workshops/migrate/route.ts
autonomous: false

must_haves:
  truths:
    - "Authenticated user visiting / is redirected to /dashboard"
    - "Dashboard page shows user's name and a placeholder workshop list"
    - "/admin page is only accessible to admin role users"
    - "Non-admin visiting /admin is silently redirected to /dashboard"
    - "Header shows sign-in link for unauthenticated users and UserButton for authenticated users"
    - "Anonymous session data can be saved to and loaded from localStorage"
    - "Anonymous session migration endpoint accepts workshop data and creates database records"
  artifacts:
    - path: "src/app/dashboard/page.tsx"
      provides: "Authenticated user dashboard with workshop list placeholder"
      contains: "auth()"
    - path: "src/app/admin/page.tsx"
      provides: "Admin-only page with defense-in-depth auth check"
      contains: "admin"
    - path: "src/components/layout/header.tsx"
      provides: "App header with conditional auth UI (sign-in link or UserButton)"
      exports: ["Header"]
      contains: "UserButton"
    - path: "src/lib/auth/anonymous-session.ts"
      provides: "localStorage session management for anonymous users"
      exports: ["getAnonymousSession", "saveAnonymousSession", "clearAnonymousSession", "migrateAnonymousSession"]
      contains: "localStorage"
    - path: "src/app/api/workshops/migrate/route.ts"
      provides: "API endpoint to migrate anonymous session data to authenticated user"
      exports: ["POST"]
      contains: "auth()"
  key_links:
    - from: "src/app/dashboard/page.tsx"
      to: "@clerk/nextjs/server"
      via: "auth() for defense-in-depth user verification"
      pattern: "await auth\\(\\)"
    - from: "src/app/admin/page.tsx"
      to: "src/lib/auth/roles.ts"
      via: "Role check for admin access"
      pattern: "isAdmin|checkRole"
    - from: "src/components/layout/header.tsx"
      to: "@clerk/nextjs"
      via: "UserButton and SignedIn/SignedOut components"
      pattern: "UserButton"
    - from: "src/lib/auth/anonymous-session.ts"
      to: "src/app/api/workshops/migrate/route.ts"
      via: "fetch POST to /api/workshops/migrate"
      pattern: "fetch.*api/workshops/migrate"
    - from: "src/app/page.tsx"
      to: "src/components/auth/sign-in-modal.tsx"
      via: "Modal rendering for sign-in on landing page"
      pattern: "SignInModal"
---

<objective>
Wire together all auth components: create protected route pages (dashboard, admin), build the app header with conditional auth UI, update the landing page with sign-in modal integration, and implement anonymous session management with migration. This plan ties Plans 01-03 into a working auth experience.

Purpose: This is the integration plan. Without it, individual pieces (middleware, modals, webhook) don't form a usable auth flow. After this plan, a user can sign up, see their dashboard, and the admin can access admin routes.
Output: Complete working authentication flow with route protection, header navigation, and anonymous session infrastructure.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-authentication-roles/02-CONTEXT.md
@.planning/phases/02-authentication-roles/02-RESEARCH.md
@.planning/phases/02-authentication-roles/02-01-SUMMARY.md
@.planning/phases/02-authentication-roles/02-02-SUMMARY.md
@.planning/phases/02-authentication-roles/02-03-SUMMARY.md
@src/db/schema/workshops.ts
@src/db/schema/users.ts
@src/db/client.ts
@src/components/Logo.tsx
@src/app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create header, dashboard, and admin pages with auth integration</name>
  <files>src/components/layout/header.tsx, src/app/dashboard/page.tsx, src/app/admin/page.tsx, src/app/page.tsx, src/app/layout.tsx</files>
  <action>
    1. Create `src/components/layout/header.tsx`:
       - Mark as 'use client' (uses Clerk client-side hooks)
       - Import UserButton, SignedIn, SignedOut from '@clerk/nextjs'
       - Import Logo from '@/components/Logo'
       - Import Link from 'next/link'
       - Import useState from 'react'
       - Import SignInModal and SignUpModal from '@/components/auth/sign-in-modal' and sign-up-modal

       - Props: none needed (reads auth state from Clerk context)

       - Layout: fixed top, full width, z-40, white background, shadow-sm, h-16
         * Left: Logo component (size 'sm') wrapped in Link to '/'
         * Right section:
           - SignedOut: "Sign in" button that opens SignInModal
           - SignedIn: UserButton component from Clerk (shows avatar, dropdown with sign-out, profile)

       - State: manage sign-in vs sign-up modal open states
         * signInOpen: boolean
         * signUpOpen: boolean
         * Switching between modals: close one, open the other

       - Per user decision: sign-in link visible in landing page header/nav for returning users
       - Per user decision: display name shown in header/nav only (UserButton handles this)
       - Per user decision: avatars use Clerk-provided (UserButton handles this automatically)

    2. Create `src/app/dashboard/page.tsx`:
       - Server Component (NOT 'use client')
       - Import auth from '@clerk/nextjs/server'
       - Import redirect from 'next/navigation'
       - Import db from '@/db/client' and users from '@/db/schema'
       - Import eq from 'drizzle-orm'

       - Defense in depth: call `const { userId } = await auth()`. If no userId, redirect('/').
       - Query user from database: `db.query.users.findFirst({ where: eq(users.clerkUserId, userId) })`
       - If user not found (webhook race condition per research Pitfall 4): show "Setting up your account..." message. This is acceptable for MVP — the webhook typically completes within 100-500ms.

       - Render:
         * Page title: "Dashboard" or "Your Workshops"
         * Welcome message with user's first name (from DB record)
         * Placeholder workshop list area: "You haven't created any workshops yet. Start your first design thinking workshop!" with a future "Start Workshop" button (disabled/placeholder for now — workshop creation is Phase 3)
         * Per user decision: dashboard shows list of all workshops (structure ready, data coming in Phase 3)

       - NOTE: Do NOT implement admin dashboard UI (deferred per user decision). This is just the user's personal dashboard.

    3. Create `src/app/admin/page.tsx`:
       - Server Component
       - Import auth from '@clerk/nextjs/server'
       - Import redirect from 'next/navigation'
       - Import getUserRoles from '@/lib/auth/roles'

       - Defense in depth (CVE-2025-29927 mitigation): check auth AND role at component level, not just middleware
       - Call `const { userId, sessionClaims } = await auth()`. If no userId, redirect('/').
       - Check roles: if not admin (via getUserRoles or isAdmin from roles.ts), redirect to '/dashboard' silently (per user decision)

       - Render minimal admin page:
         * Title: "Admin"
         * Subtitle: "Admin tools and management"
         * Placeholder content: "Admin functionality coming soon."
         * Per deferred decision: admin dashboard UI is out of scope. Just a protected stub page that proves admin route protection works.

    4. Update `src/app/page.tsx` (landing page):
       - Keep existing landing page content
       - Add 'use client' directive (needs state for modal)
       - Add state for sign-in/sign-up modal (in case unauthenticated user clicks sign-in from header — but since header already manages its own modal state, the landing page itself doesn't need modal state)
       - Actually, keep the landing page as a Server Component if possible. The Header component handles its own modal state as a client component. The landing page just renders Header + content.
       - Per user decision: signed-in users visiting landing page auto-redirect to dashboard. This is handled by middleware (Plan 01), not the page itself. The page can remain a simple Server Component.
       - Update: import and render Header component at top of the page

    5. Update `src/app/layout.tsx`:
       - Do NOT add Header to layout.tsx globally. The Header should only appear on app pages (dashboard, admin, workshop), not necessarily on the landing page in the same way. Actually per user decision, sign-in link should be visible on landing page too. So the Header IS appropriate in layout.tsx.
       - However, putting Header in layout means it appears on ALL pages. For MVP 0.5 this is fine — the landing page will have a header with sign-in, and dashboard/admin will have a header with UserButton.
       - Add Header import and render it at the top of the body content, before {children}
       - Add a main wrapper with pt-16 (to account for fixed header height) around {children}
  </action>
  <verify>
    - `npm run build` passes
    - Visiting /dashboard while unauthenticated redirects to / (middleware + component check)
    - Visiting /admin while unauthenticated redirects to / (middleware + component check)
    - Visiting /admin as non-admin redirects to /dashboard (middleware + component check)
    - Header renders with Logo on left and sign-in button on right (when not authenticated)
    - Landing page shows header with sign-in option
  </verify>
  <done>Header shows sign-in for guests and UserButton for authenticated users. Dashboard page verifies auth and shows welcome message + workshop placeholder. Admin page verifies admin role with defense-in-depth. Landing page includes header. Layout wraps all pages with header.</done>
</task>

<task type="auto">
  <name>Task 2: Create anonymous session management and migration endpoint</name>
  <files>src/lib/auth/anonymous-session.ts, src/app/api/workshops/migrate/route.ts</files>
  <action>
    1. Create `src/lib/auth/anonymous-session.ts`:
       - Per user decision: anonymous session data saved in localStorage for browser persistence
       - Per user decision: anonymous users get one active workshop at a time

       - Define AnonymousSession Zod schema (zod v4 is installed):
         ```
         workshopTitle: z.string().optional()
         originalIdea: z.string().optional()
         steps: z.array(z.object({
           stepId: z.string(),
           status: z.enum(['not_started', 'in_progress', 'complete']),
           output: z.record(z.string(), z.unknown()).optional(),
           completedAt: z.string().optional(),
         }))
         createdAt: z.string()
         updatedAt: z.string()
         migrated: z.boolean().optional()
         ```

       - Export type AnonymousSession = z.infer<typeof AnonymousSessionSchema>

       - STORAGE_KEY constant: 'workshoppilot_anonymous_session'

       - getAnonymousSession(): AnonymousSession | null
         * Check typeof window (SSR guard)
         * Read from localStorage, parse JSON, validate with Zod schema
         * Return null if not found, parse fails, or validation fails
         * Log parse errors to console.error

       - saveAnonymousSession(session: AnonymousSession): void
         * SSR guard
         * JSON.stringify and save to localStorage
         * Log errors

       - clearAnonymousSession(): void
         * SSR guard
         * Remove from localStorage

       - migrateAnonymousSession(): Promise<{ workshopId: string } | null>
         * Read anonymous session from localStorage
         * If no session or already migrated (session.migrated === true), return null
         * POST to /api/workshops/migrate with session data
         * On success: mark session as migrated (save with migrated: true), then clear after short delay
         * On failure: log error, keep data in localStorage for retry (per research: retain on failure)
         * Return { workshopId } from API response on success

       - testLocalStorage(): boolean
         * Try set/get/remove test item
         * Return false if throws (per research Pitfall 5: detect storage issues)

    2. Create `src/app/api/workshops/migrate/route.ts`:
       - Import auth from '@clerk/nextjs/server'
       - Import db from '@/db/client'
       - Import workshops, workshopSteps from '@/db/schema'
       - Import NextResponse from 'next/server'
       - Import createPrefixedId from '@/lib/ids'

       - Export async POST function:
         * Defense in depth: verify auth with `const { userId } = await auth()`. If no userId, return 401.
         * Parse request body: extract anonymousSession data
         * Validate session data (basic checks: has steps array)

         * Create workshop record:
           - Insert into workshops table:
             * clerkUserId: userId
             * title: anonymousSession.workshopTitle || 'My Workshop'
             * originalIdea: anonymousSession.originalIdea || ''
             * status: 'active'
           - Use .returning() to get the workshop ID

         * Create workshop step records (if steps exist in session):
           - Map anonymous steps to workshopSteps inserts:
             * workshopId: created workshop ID
             * stepId: step.stepId (matches step_definitions semantic IDs: 'empathize', 'define', 'ideate')
             * status: step.status
             * output: step.output (JSON)
             * completedAt: step.completedAt ? new Date(step.completedAt) : null

         * Return 200 with { workshopId: workshop.id }

       - Error handling: try/catch with 500 response on database errors

       - Note: This endpoint is protected by middleware (matches /api/workshops(.*) in isProtectedRoute).
  </action>
  <verify>
    - `npm run build` passes
    - anonymous-session.ts exports all functions: getAnonymousSession, saveAnonymousSession, clearAnonymousSession, migrateAnonymousSession, testLocalStorage
    - migrate/route.ts exports POST handler
    - `curl -X POST http://localhost:3000/api/workshops/migrate` returns 401 (unauthenticated)
  </verify>
  <done>Anonymous session utilities handle localStorage CRUD with Zod validation. Migration endpoint creates workshop + step records from anonymous session data for authenticated users. Ready for Phase 3 to use when workshop flow is built.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete auth flow</name>
  <what-built>Complete authentication system: Clerk sign-up/sign-in via modals, route protection (dashboard requires auth, admin requires admin role), header with conditional auth UI, webhook user sync, and anonymous session management.</what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Visit http://localhost:3000 — should see landing page with header containing "Sign in" button
    3. Click "Sign in" — modal should appear with Clerk sign-in form
    4. Close modal — should return to landing page
    5. Try visiting http://localhost:3000/dashboard — should redirect to landing page (unauthenticated)
    6. Try visiting http://localhost:3000/admin — should redirect to landing page (unauthenticated)
    7. Sign up with email + password via the sign-in modal (switch to sign-up)
    8. After sign-up, should redirect to /dashboard
    9. Dashboard should show welcome message with your name
    10. Header should now show UserButton (avatar/dropdown) instead of "Sign in"
    11. Check Neon/Drizzle Studio: users table should have a new record with your clerkUserId
    12. Visit /admin — if your email doesn't match ADMIN_EMAIL, should silently redirect to /dashboard
    13. Sign out (via UserButton dropdown)
    14. Should return to landing page
    15. Visit /dashboard again — should redirect to landing page (session cleared)
  </how-to-verify>
  <resume-signal>Type "approved" if auth flow works correctly, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. Landing page → Header with sign-in → Modal auth → Dashboard redirect flow works
3. Dashboard page verifies auth server-side (defense in depth)
4. Admin page verifies admin role server-side (defense in depth)
5. Header conditionally shows sign-in or UserButton
6. Anonymous session functions importable and functional
7. Migration endpoint returns 401 for unauthenticated requests
8. Human verification confirms end-to-end auth flow
</verification>

<success_criteria>
- Header renders sign-in link for guests, UserButton for authenticated users
- Dashboard is auth-protected at both middleware and component level
- Admin is role-protected at both middleware and component level
- Non-admin visiting /admin silently redirects to /dashboard
- Authenticated user visiting / auto-redirects to /dashboard
- Anonymous session utilities export all CRUD functions with Zod validation
- Migration endpoint creates workshop records from anonymous session data
- End-to-end sign-up → dashboard flow verified by user
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-roles/02-04-SUMMARY.md`
</output>
