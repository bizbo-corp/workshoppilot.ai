---
phase: 02-authentication-roles
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - src/app/dashboard/page.tsx
  - src/app/admin/page.tsx
  - src/components/layout/header.tsx
  - src/app/page.tsx
  - src/app/layout.tsx
  - src/lib/auth/anonymous-session.ts
  - src/app/api/workshops/migrate/route.ts
  - src/components/auth/migration-check.tsx
autonomous: false

must_haves:
  truths:
    - "Authenticated user visiting / is redirected to /dashboard"
    - "Dashboard page shows user's name and a placeholder workshop list"
    - "/admin page is only accessible to admin role users"
    - "Non-admin visiting /admin is silently redirected to /dashboard"
    - "Header shows sign-in link for unauthenticated users and UserButton for authenticated users"
    - "Anonymous session data can be saved to and loaded from localStorage"
    - "Anonymous session migration endpoint accepts workshop data and creates database records"
    - "After sign-up, anonymous session data is automatically migrated on first authenticated page load (dashboard). Phase 2 redirects to /dashboard as a temporary destination; Phase 3 MUST update ClerkProvider signUpFallbackRedirectUrl and auth wall redirect to point to the workshop step 4 URL instead."
    - "Migration is triggered automatically by a client component on the dashboard page -- no manual user action required"
  artifacts:
    - path: "src/app/dashboard/page.tsx"
      provides: "Authenticated user dashboard with workshop list placeholder"
      contains: "auth()"
    - path: "src/app/admin/page.tsx"
      provides: "Admin-only page with defense-in-depth auth check"
      contains: "admin"
    - path: "src/components/layout/header.tsx"
      provides: "App header with conditional auth UI (sign-in link or UserButton)"
      exports: ["Header"]
      contains: "UserButton"
    - path: "src/lib/auth/anonymous-session.ts"
      provides: "localStorage session management for anonymous users"
      exports: ["getAnonymousSession", "saveAnonymousSession", "clearAnonymousSession", "migrateAnonymousSession"]
      contains: "localStorage"
    - path: "src/app/api/workshops/migrate/route.ts"
      provides: "API endpoint to migrate anonymous session data to authenticated user"
      exports: ["POST"]
      contains: "auth()"
    - path: "src/components/auth/migration-check.tsx"
      provides: "Client component that auto-triggers anonymous session migration on mount"
      exports: ["MigrationCheck"]
      contains: "migrateAnonymousSession"
  key_links:
    - from: "src/app/dashboard/page.tsx"
      to: "@clerk/nextjs/server"
      via: "auth() for defense-in-depth user verification"
      pattern: "await auth\\(\\)"
    - from: "src/app/admin/page.tsx"
      to: "src/lib/auth/roles.ts"
      via: "Role check for admin access"
      pattern: "isAdmin|checkRole"
    - from: "src/components/layout/header.tsx"
      to: "@clerk/nextjs"
      via: "UserButton and SignedIn/SignedOut components"
      pattern: "UserButton"
    - from: "src/lib/auth/anonymous-session.ts"
      to: "src/app/api/workshops/migrate/route.ts"
      via: "fetch POST to /api/workshops/migrate"
      pattern: "fetch.*api/workshops/migrate"
    - from: "src/app/page.tsx"
      to: "src/components/auth/sign-in-modal.tsx"
      via: "Modal rendering for sign-in on landing page"
      pattern: "SignInModal"
    - from: "src/components/auth/migration-check.tsx"
      to: "src/lib/auth/anonymous-session.ts"
      via: "Calls migrateAnonymousSession on mount"
      pattern: "migrateAnonymousSession"
    - from: "src/app/dashboard/page.tsx"
      to: "src/components/auth/migration-check.tsx"
      via: "Renders MigrationCheck client component"
      pattern: "MigrationCheck"
---

<objective>
Wire together all auth components: create protected route pages (dashboard, admin), build the app header with conditional auth UI, update the landing page with sign-in modal integration, implement anonymous session management with migration, and wire automatic migration triggering on first authenticated page load. This plan ties Plans 01-03 into a working auth experience.

Purpose: This is the integration plan. Without it, individual pieces (middleware, modals, webhook) don't form a usable auth flow. After this plan, a user can sign up, see their dashboard, and the admin can access admin routes. Anonymous session data is automatically migrated when a new user first reaches the dashboard after sign-up.
Output: Complete working authentication flow with route protection, header navigation, anonymous session infrastructure, and automatic migration wiring.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-authentication-roles/02-CONTEXT.md
@.planning/phases/02-authentication-roles/02-RESEARCH.md
@.planning/phases/02-authentication-roles/02-01-SUMMARY.md
@.planning/phases/02-authentication-roles/02-02-SUMMARY.md
@.planning/phases/02-authentication-roles/02-03-SUMMARY.md
@src/db/schema/workshops.ts
@src/db/schema/users.ts
@src/db/client.ts
@src/components/Logo.tsx
@src/app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create header, dashboard, and admin pages with auth integration</name>
  <files>src/components/layout/header.tsx, src/app/dashboard/page.tsx, src/app/admin/page.tsx, src/app/page.tsx, src/app/layout.tsx</files>
  <action>
    1. Create `src/components/layout/header.tsx`:
       - Mark as 'use client' (uses Clerk client-side hooks)
       - Import UserButton, SignedIn, SignedOut from '@clerk/nextjs'
       - Import Logo from '@/components/Logo'
       - Import Link from 'next/link'
       - Import useState from 'react'
       - Import SignInModal and SignUpModal from '@/components/auth/sign-in-modal' and sign-up-modal

       - Props: none needed (reads auth state from Clerk context)

       - Layout: fixed top, full width, z-40, white background, shadow-sm, h-16
         * Left: Logo component (size 'sm') wrapped in Link to '/'
         * Right section:
           - SignedOut: "Sign in" button that opens SignInModal
           - SignedIn: UserButton component from Clerk (shows avatar, dropdown with sign-out, profile)

       - State: manage sign-in vs sign-up modal open states
         * signInOpen: boolean
         * signUpOpen: boolean
         * Switching between modals: close one, open the other

       - Per user decision: sign-in link visible in landing page header/nav for returning users
       - Per user decision: display name shown in header/nav only (UserButton handles this)
       - Per user decision: avatars use Clerk-provided (UserButton handles this automatically)

    2. Create `src/app/dashboard/page.tsx`:
       - Server Component (NOT 'use client')
       - Import auth from '@clerk/nextjs/server'
       - Import redirect from 'next/navigation'
       - Import db from '@/db/client' and users from '@/db/schema'
       - Import eq from 'drizzle-orm'
       - Import MigrationCheck from '@/components/auth/migration-check'

       - Defense in depth: call `const { userId } = await auth()`. If no userId, redirect('/').
       - Query user from database: `db.query.users.findFirst({ where: eq(users.clerkUserId, userId) })`
       - If user not found (webhook race condition per research Pitfall 4): show "Setting up your account..." message. This is acceptable for MVP -- the webhook typically completes within 100-500ms.

       - Render:
         * **Include <MigrationCheck /> client component** at the top of the page content. This handles automatic anonymous session migration (see Task 2 for implementation).
         * Page title: "Dashboard" or "Your Workshops"
         * Welcome message with user's first name (from DB record)
         * Placeholder workshop list area: "You haven't created any workshops yet. Start your first design thinking workshop!" with a future "Start Workshop" button (disabled/placeholder for now -- workshop creation is Phase 3)
         * Per user decision: dashboard shows list of all workshops (structure ready, data coming in Phase 3)

       - NOTE: Do NOT implement admin dashboard UI (deferred per user decision). This is just the user's personal dashboard.

    3. Create `src/app/admin/page.tsx`:
       - Server Component
       - Import auth from '@clerk/nextjs/server'
       - Import redirect from 'next/navigation'
       - Import getUserRoles from '@/lib/auth/roles'

       - Defense in depth (CVE-2025-29927 mitigation): check auth AND role at component level, not just middleware
       - Call `const { userId, sessionClaims } = await auth()`. If no userId, redirect('/').
       - Check roles: if not admin (via getUserRoles or isAdmin from roles.ts), redirect to '/dashboard' silently (per user decision)

       - Render minimal admin page:
         * Title: "Admin"
         * Subtitle: "Admin tools and management"
         * Placeholder content: "Admin functionality coming soon."
         * Per deferred decision: admin dashboard UI is out of scope. Just a protected stub page that proves admin route protection works.

    4. Update `src/app/page.tsx` (landing page):
       - Keep existing landing page content
       - Add 'use client' directive (needs state for modal)
       - Add state for sign-in/sign-up modal (in case unauthenticated user clicks sign-in from header -- but since header already manages its own modal state, the landing page itself doesn't need modal state)
       - Actually, keep the landing page as a Server Component if possible. The Header component handles its own modal state as a client component. The landing page just renders Header + content.
       - Per user decision: signed-in users visiting landing page auto-redirect to dashboard. This is handled by middleware (Plan 01), not the page itself. The page can remain a simple Server Component.
       - Update: import and render Header component at top of the page

    5. Update `src/app/layout.tsx`:
       - Do NOT add Header to layout.tsx globally. The Header should only appear on app pages (dashboard, admin, workshop), not necessarily on the landing page in the same way. Actually per user decision, sign-in link should be visible on landing page too. So the Header IS appropriate in layout.tsx.
       - However, putting Header in layout means it appears on ALL pages. For MVP 0.5 this is fine -- the landing page will have a header with sign-in, and dashboard/admin will have a header with UserButton.
       - Add Header import and render it at the top of the body content, before {children}
       - Add a main wrapper with pt-16 (to account for fixed header height) around {children}
  </action>
  <verify>
    - `npm run build` passes
    - Visiting /dashboard while unauthenticated redirects to / (middleware + component check)
    - Visiting /admin while unauthenticated redirects to / (middleware + component check)
    - Visiting /admin as non-admin redirects to /dashboard (middleware + component check)
    - Header renders with Logo on left and sign-in button on right (when not authenticated)
    - Landing page shows header with sign-in option
    - Dashboard page renders MigrationCheck component (verify in page source or React DevTools)
  </verify>
  <done>Header shows sign-in for guests and UserButton for authenticated users. Dashboard page verifies auth and shows welcome message + workshop placeholder. Dashboard includes MigrationCheck component for automatic anonymous session migration. Admin page verifies admin role with defense-in-depth. Landing page includes header. Layout wraps all pages with header.</done>
</task>

<task type="auto">
  <name>Task 2: Create anonymous session management, migration endpoint, and migration trigger</name>
  <files>src/lib/auth/anonymous-session.ts, src/app/api/workshops/migrate/route.ts, src/components/auth/migration-check.tsx</files>
  <action>
    1. Create `src/lib/auth/anonymous-session.ts`:
       - Per user decision: anonymous session data saved in localStorage for browser persistence
       - Per user decision: anonymous users get one active workshop at a time

       - Define AnonymousSession Zod schema (zod v4 is installed):
         ```
         workshopTitle: z.string().optional()
         originalIdea: z.string().optional()
         steps: z.array(z.object({
           stepId: z.string(),
           status: z.enum(['not_started', 'in_progress', 'complete']),
           output: z.record(z.string(), z.unknown()).optional(),
           completedAt: z.string().optional(),
         }))
         createdAt: z.string()
         updatedAt: z.string()
         migrated: z.boolean().optional()
         ```

       - Export type AnonymousSession = z.infer<typeof AnonymousSessionSchema>

       - STORAGE_KEY constant: 'workshoppilot_anonymous_session'

       - getAnonymousSession(): AnonymousSession | null
         * Check typeof window (SSR guard)
         * Read from localStorage, parse JSON, validate with Zod schema
         * Return null if not found, parse fails, or validation fails
         * Log parse errors to console.error

       - saveAnonymousSession(session: AnonymousSession): void
         * SSR guard
         * JSON.stringify and save to localStorage
         * Log errors

       - clearAnonymousSession(): void
         * SSR guard
         * Remove from localStorage

       - migrateAnonymousSession(): Promise<{ workshopId: string } | null>
         * Read anonymous session from localStorage
         * If no session or already migrated (session.migrated === true), return null
         * POST to /api/workshops/migrate with session data
         * On success: mark session as migrated (save with migrated: true), then clear after short delay
         * On failure: log error, keep data in localStorage for retry (per research: retain on failure)
         * Return { workshopId } from API response on success

       - testLocalStorage(): boolean
         * Try set/get/remove test item
         * Return false if throws (per research Pitfall 5: detect storage issues)

    2. Create `src/app/api/workshops/migrate/route.ts`:
       - Import auth from '@clerk/nextjs/server'
       - Import db from '@/db/client'
       - Import workshops, workshopSteps from '@/db/schema'
       - Import NextResponse from 'next/server'
       - Import createPrefixedId from '@/lib/ids'

       - Export async POST function:
         * Defense in depth: verify auth with `const { userId } = await auth()`. If no userId, return 401.
         * Parse request body: extract anonymousSession data
         * Validate session data (basic checks: has steps array)

         * Create workshop record:
           - Insert into workshops table:
             * clerkUserId: userId
             * title: anonymousSession.workshopTitle || 'My Workshop'
             * originalIdea: anonymousSession.originalIdea || ''
             * status: 'active'
           - Use .returning() to get the workshop ID

         * Create workshop step records (if steps exist in session):
           - Map anonymous steps to workshopSteps inserts:
             * workshopId: created workshop ID
             * stepId: step.stepId (matches step_definitions semantic IDs: 'empathize', 'define', 'ideate')
             * status: step.status
             * output: step.output (JSON)
             * completedAt: step.completedAt ? new Date(step.completedAt) : null

         * Return 200 with { workshopId: workshop.id }

       - Error handling: try/catch with 500 response on database errors

       - Note: This endpoint is protected by middleware (matches /api/workshops(.*) in isProtectedRoute).

    3. Create `src/components/auth/migration-check.tsx`:
       - Mark as 'use client'
       - This component auto-triggers anonymous session migration on first authenticated page load.

       - Import { useEffect, useRef } from 'react'
       - Import { getAnonymousSession, migrateAnonymousSession, clearAnonymousSession } from '@/lib/auth/anonymous-session'

       - Implementation:
         * Use a ref (hasChecked) to ensure migration only runs once per mount
         * useEffect on mount (empty dependency array):
           1. If hasChecked.current is true, return early
           2. Set hasChecked.current = true
           3. Call getAnonymousSession()
           4. If no session exists OR session.migrated === true, return (nothing to migrate)
           5. Call migrateAnonymousSession()
           6. If successful, call clearAnonymousSession() to clean up localStorage
           7. Log result to console (success or failure) for debugging
           8. Do NOT redirect anywhere -- the user is already on the dashboard, which is correct for Phase 2. Phase 3 will update this to redirect to the workshop step 4 URL after migration.

       - Render: return null (invisible component, no UI)

       - This component is rendered inside dashboard/page.tsx (Task 1 above).
         When a user signs up and lands on /dashboard, this component:
         1. Checks localStorage for anonymous session data
         2. If found, POSTs to /api/workshops/migrate
         3. Clears localStorage after successful migration
         4. The migration happens transparently -- user just sees their dashboard

       - PHASE 3 HANDOFF: When workshop routes exist, Phase 3 should:
         a. Update ClerkProvider's signUpFallbackRedirectUrl from '/dashboard' to the workshop step 4 URL
         b. Update auth wall modal's redirect to point to step 4
         c. Optionally enhance MigrationCheck to redirect to the migrated workshop's step 4 after successful migration
  </action>
  <verify>
    - `npm run build` passes
    - anonymous-session.ts exports all functions: getAnonymousSession, saveAnonymousSession, clearAnonymousSession, migrateAnonymousSession, testLocalStorage
    - migrate/route.ts exports POST handler
    - migration-check.tsx exports MigrationCheck component
    - `curl -X POST http://localhost:3000/api/workshops/migrate` returns 401 (unauthenticated)
    - MigrationCheck renders null (no visible UI) but contains useEffect with migrateAnonymousSession call
  </verify>
  <done>Anonymous session utilities handle localStorage CRUD with Zod validation. Migration endpoint creates workshop + step records from anonymous session data for authenticated users. MigrationCheck component auto-triggers migration on first authenticated dashboard load. The complete flow: anonymous user completes steps 1-3 -> data saved to localStorage -> user signs up -> redirected to /dashboard -> MigrationCheck fires -> anonymous data migrated to DB -> localStorage cleared. Ready for Phase 3 to update redirect destination from /dashboard to workshop step 4.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete auth flow</name>
  <what-built>Complete authentication system: Clerk sign-up/sign-in via modals, route protection (dashboard requires auth, admin requires admin role), header with conditional auth UI, webhook user sync, anonymous session management, and automatic migration triggering on dashboard load.</what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Visit http://localhost:3000 -- should see landing page with header containing "Sign in" button
    3. Click "Sign in" -- modal should appear with Clerk sign-in form
    4. Close modal -- should return to landing page
    5. Try visiting http://localhost:3000/dashboard -- should redirect to landing page (unauthenticated)
    6. Try visiting http://localhost:3000/admin -- should redirect to landing page (unauthenticated)
    7. Sign up with email + password via the sign-in modal (switch to sign-up)
    8. After sign-up, should redirect to /dashboard
    9. Dashboard should show welcome message with your name
    10. Header should now show UserButton (avatar/dropdown) instead of "Sign in"
    11. Check Neon/Drizzle Studio: users table should have a new record with your clerkUserId
    12. Visit /admin -- if your email doesn't match ADMIN_EMAIL, should silently redirect to /dashboard
    13. Open browser DevTools console -- confirm no migration errors (MigrationCheck runs silently; since there's no anonymous session data yet, it should exit cleanly)
    14. Sign out (via UserButton dropdown)
    15. Should return to landing page
    16. Visit /dashboard again -- should redirect to landing page (session cleared)
  </how-to-verify>
  <resume-signal>Type "approved" if auth flow works correctly, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. Landing page -> Header with sign-in -> Modal auth -> Dashboard redirect flow works
3. Dashboard page verifies auth server-side (defense in depth)
4. Admin page verifies admin role server-side (defense in depth)
5. Header conditionally shows sign-in or UserButton
6. Anonymous session functions importable and functional
7. Migration endpoint returns 401 for unauthenticated requests
8. MigrationCheck component exists and is rendered in dashboard page
9. Human verification confirms end-to-end auth flow
</verification>

<success_criteria>
- Header renders sign-in link for guests, UserButton for authenticated users
- Dashboard is auth-protected at both middleware and component level
- Admin is role-protected at both middleware and component level
- Non-admin visiting /admin silently redirects to /dashboard
- Authenticated user visiting / auto-redirects to /dashboard
- Anonymous session utilities export all CRUD functions with Zod validation
- Migration endpoint creates workshop records from anonymous session data
- MigrationCheck component auto-triggers migration on dashboard mount (checks localStorage, calls API if data exists, clears after success)
- End-to-end sign-up -> dashboard flow verified by user
- PHASE 2->3 HANDOFF: /dashboard is the temporary post-sign-up redirect destination. Phase 3 MUST update: (1) ClerkProvider signUpFallbackRedirectUrl to workshop step 4 URL, (2) auth wall modal redirect to step 4, (3) optionally enhance MigrationCheck to redirect to migrated workshop step 4. Per user decision (LOCKED): "After sign-up (at auth wall), user continues directly to step 4 -- no intermediate dashboard."
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-roles/02-04-SUMMARY.md`
</output>
