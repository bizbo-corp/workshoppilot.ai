---
phase: 02-authentication-roles
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/api/webhooks/clerk/route.ts
  - src/lib/auth/roles.ts
autonomous: true
user_setup:
  - service: clerk
    why: "Webhook endpoint for user sync"
    env_vars:
      - name: CLERK_WEBHOOK_SECRET
        source: "Clerk Dashboard -> Webhooks -> Add Endpoint -> Signing Secret"
    dashboard_config:
      - task: "Add webhook endpoint URL (e.g., https://<ngrok-or-deployed-url>/api/webhooks/clerk) and subscribe to user.created, user.updated, user.deleted events"
        location: "Clerk Dashboard -> Configure -> Webhooks -> Add Endpoint"

must_haves:
  truths:
    - "When a user signs up in Clerk, a corresponding record is created in the users database table"
    - "Admin email (from ADMIN_EMAIL env var) gets facilitator + admin roles assigned in Clerk publicMetadata"
    - "Non-admin users get facilitator role assigned by default"
    - "User deletion via Clerk triggers soft delete in database (deletedAt set, record kept)"
  artifacts:
    - path: "src/app/api/webhooks/clerk/route.ts"
      provides: "Webhook handler for Clerk user lifecycle events"
      exports: ["POST"]
      contains: "user.created"
    - path: "src/lib/auth/roles.ts"
      provides: "Role checking utilities and type definitions"
      exports: ["UserRole", "checkRole", "getUserRoles", "initializeUserRoles"]
      contains: "publicMetadata"
  key_links:
    - from: "src/app/api/webhooks/clerk/route.ts"
      to: "src/db/schema/users.ts"
      via: "Database insert on user.created event"
      pattern: "db\\.insert.*users"
    - from: "src/app/api/webhooks/clerk/route.ts"
      to: "src/lib/auth/roles.ts"
      via: "initializeUserRoles call after user creation"
      pattern: "initializeUserRoles"
    - from: "src/app/api/webhooks/clerk/route.ts"
      to: "svix"
      via: "Webhook signature verification"
      pattern: "new Webhook.*verify"
---

<objective>
Create the Clerk webhook endpoint for user lifecycle sync and build role management utilities. When users sign up, update, or delete their Clerk account, the database stays in sync. Roles (facilitator/admin) are assigned via Clerk publicMetadata on user creation.

Purpose: User sync and role assignment are prerequisites for route protection (Plan 04) and auth UI (Plan 03). Without the webhook, there's no database record for authenticated users.
Output: Working webhook endpoint and role utility functions.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-authentication-roles/02-CONTEXT.md
@.planning/phases/02-authentication-roles/02-RESEARCH.md
@src/db/schema/users.ts
@src/db/client.ts
@src/db/schema/workshops.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create role management utilities</name>
  <files>src/lib/auth/roles.ts</files>
  <action>
    Create `src/lib/auth/roles.ts` with the following:

    1. Define UserRole type: `'facilitator' | 'admin'`

    2. `getUserRoles(sessionClaims)`: Extract roles from Clerk session claims.
       - Accept sessionClaims parameter (type from @clerk/nextjs/server)
       - Read roles from `sessionClaims?.publicMetadata?.roles` (Clerk stores publicMetadata directly on session claims in recent versions)
       - Return UserRole[] array, defaulting to `['facilitator']` if not set
       - Handle case where roles might be undefined or malformed

    3. `checkRole(sessionClaims, role: UserRole)`: Check if a specific role exists.
       - Calls getUserRoles internally
       - Returns boolean

    4. `isAdmin(sessionClaims)`: Convenience function for admin check.
       - Returns checkRole(sessionClaims, 'admin')

    5. `initializeUserRoles(clerkUserId: string, email: string)`: Assign roles on user creation.
       - Import clerkClient from '@clerk/nextjs/server'
       - Check if email matches process.env.ADMIN_EMAIL
       - If admin email: assign roles `['facilitator', 'admin']`
       - If not admin: assign roles `['facilitator']`
       - Call `(await clerkClient()).users.updateUserMetadata(clerkUserId, { publicMetadata: { roles } })`
       - Per user decision: everyone starts as facilitator, admin identified by ADMIN_EMAIL env var
       - Per user decision: admin = facilitator + admin access

    6. Export all functions and the UserRole type.

    All functions should be async where they call Clerk APIs. Session-reading functions (getUserRoles, checkRole, isAdmin) should be synchronous since they just parse claims data.
  </action>
  <verify>
    - `npm run build` passes (TypeScript compilation succeeds)
    - File exports UserRole type and all four functions
    - No import errors for @clerk/nextjs/server
  </verify>
  <done>Role utilities exist: getUserRoles parses session claims, checkRole/isAdmin check specific roles, initializeUserRoles assigns roles via Clerk publicMetadata API. Admin detection uses ADMIN_EMAIL env var.</done>
</task>

<task type="auto">
  <name>Task 2: Create Clerk webhook endpoint for user sync</name>
  <files>src/app/api/webhooks/clerk/route.ts</files>
  <action>
    Create `src/app/api/webhooks/clerk/route.ts` as a Next.js App Router route handler:

    1. Import Webhook from 'svix', headers from 'next/headers', db from '@/db/client', users from '@/db/schema', eq from 'drizzle-orm', NextResponse from 'next/server', and initializeUserRoles from '@/lib/auth/roles'.

    2. Export async POST function (the webhook handler):

    3. **Verify webhook signature** (per research: ALWAYS verify to prevent spoofing):
       - Read CLERK_WEBHOOK_SECRET from process.env (throw if missing)
       - Get svix-id, svix-timestamp, svix-signature from request headers (using `await headers()`)
       - If any svix headers missing, return 400
       - Read request body as text, parse as JSON
       - Create new Webhook(WEBHOOK_SECRET) and call wh.verify(body, svixHeaders)
       - If verification fails, log error and return 400

    4. **Handle user.created event:**
       - Extract id, email_addresses, first_name, last_name, image_url, unsafe_metadata from evt.data
       - Get primary email from email_addresses[0]?.email_address
       - Get company from unsafe_metadata?.company (optional sign-up field per user decision)
       - Insert into users table:
         * clerkUserId: id
         * email: primaryEmail
         * firstName: first_name
         * lastName: last_name
         * imageUrl: image_url
         * company: company || null
         * roles: JSON.stringify(['facilitator']) (default role)
       - Call initializeUserRoles(id, primaryEmail) to set publicMetadata on Clerk user
       - Return 201

    5. **Handle user.updated event:**
       - Extract id, email_addresses, first_name, last_name, image_url from evt.data
       - Update users table where clerkUserId equals id:
         * email, firstName, lastName, imageUrl
         * updatedAt: new Date()
       - Return 200

    6. **Handle user.deleted event:**
       - Extract id from evt.data
       - Soft delete per user decision: set deletedAt to new Date() on users table where clerkUserId equals id
       - Also soft delete user's workshops: set deletedAt (if workshops table has deletedAt â€” check schema. If workshops doesn't have deletedAt, skip workshop soft delete and add a TODO comment noting this needs to be added later)
       - Return 200

    7. **Default handler:** Return 200 for unhandled event types (acknowledge receipt).

    8. **Error handling:** Wrap each event handler in try/catch. Log errors with console.error. Return 500 on database errors (Clerk will retry). Return 200 on unrecoverable errors to prevent infinite retries.

    Note: The webhook endpoint is listed in the middleware's public routes (isPublicRoute includes '/api/webhooks(.*)'), so it won't require authentication.
  </action>
  <verify>
    - `npm run build` passes without errors
    - File exports a POST function
    - Route is accessible at /api/webhooks/clerk (returns 400 without proper svix headers, confirming the endpoint exists and validates)
    - `curl -X POST http://localhost:3000/api/webhooks/clerk` returns 400 (missing headers)
  </verify>
  <done>Webhook endpoint handles user.created (inserts DB record + assigns roles), user.updated (syncs profile data), and user.deleted (soft deletes user and workshops). All requests are verified via svix signature.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. `src/lib/auth/roles.ts` exports UserRole, checkRole, getUserRoles, isAdmin, initializeUserRoles
3. `src/app/api/webhooks/clerk/route.ts` exports POST handler
4. Webhook endpoint returns 400 for unauthenticated requests (no svix headers)
5. Role initialization logic correctly identifies admin by ADMIN_EMAIL
</verification>

<success_criteria>
- Webhook endpoint verifies svix signatures and handles user.created, user.updated, user.deleted
- User creation inserts record with usr_ prefixed ID, email, name, company, default facilitator role
- Admin email match assigns ['facilitator', 'admin'] roles via Clerk publicMetadata
- User deletion performs soft delete (sets deletedAt, preserves record)
- Role utilities provide type-safe role checking from session claims
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-roles/02-02-SUMMARY.md`
</output>
