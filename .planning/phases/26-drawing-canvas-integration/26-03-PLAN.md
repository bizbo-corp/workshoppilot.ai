---
phase: 26-drawing-canvas-integration
plan: 03
type: execute
wave: 2
depends_on: ["26-01", "26-02"]
files_modified:
  - src/components/ezydraw/ezydraw-modal.tsx
  - src/components/canvas/react-flow-canvas.tsx
  - src/hooks/use-canvas-autosave.ts
autonomous: true

must_haves:
  truths:
    - "User saves drawing in EzyDraw modal and a DrawingImageNode appears on ReactFlow canvas"
    - "User double-clicks a DrawingImageNode and EzyDraw modal opens with original vector elements"
    - "Save flow: PNG uploaded to Vercel Blob, simplified vector JSON + PNG URL stored in stepArtifacts.drawings[]"
    - "Re-edit flow: vector JSON loaded from stepArtifacts, parsed back to DrawingElement[], passed as initialElements to EzyDraw"
    - "Updated drawing replaces the existing PNG and vector JSON (not creating a duplicate)"
    - "Canvas autosave includes drawingNodes alongside postIts and gridColumns"
  artifacts:
    - path: "src/components/ezydraw/ezydraw-modal.tsx"
      provides: "Updated modal with drawingId for re-edit mode and updated onSave signature"
      contains: "drawingId"
    - path: "src/components/canvas/react-flow-canvas.tsx"
      provides: "Complete save + re-edit wiring between EzyDraw and ReactFlow canvas"
      contains: "handleDrawingSave"
    - path: "src/hooks/use-canvas-autosave.ts"
      provides: "Autosave includes drawingNodes in persisted state"
      contains: "drawingNodes"
  key_links:
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/actions/drawing-actions.ts"
      via: "saveDrawing/updateDrawing/loadDrawing server action calls"
      pattern: "(saveDrawing|updateDrawing|loadDrawing)"
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/components/ezydraw/ezydraw-loader.tsx"
      via: "EzyDrawLoader rendered with initialElements and onSave"
      pattern: "EzyDrawLoader"
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/lib/drawing/simplify.ts"
      via: "simplifyDrawingElements called before saveDrawing"
      pattern: "simplifyDrawingElements"
---

<objective>
Wire the complete save and re-edit flows between EzyDraw modal and ReactFlow canvas, connecting the server actions (Plan 01) to the UI components (Plan 02).

Purpose: This is the integration plan that makes drawings actually work end-to-end: save from EzyDraw → appear on canvas, double-click on canvas → re-edit in EzyDraw.

Output: Working save flow, working re-edit flow, autosave integration for drawing nodes.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-drawing-canvas-integration/26-RESEARCH.md
@.planning/phases/26-drawing-canvas-integration/26-01-SUMMARY.md
@.planning/phases/26-drawing-canvas-integration/26-02-SUMMARY.md

@src/components/ezydraw/ezydraw-modal.tsx
@src/components/ezydraw/ezydraw-loader.tsx
@src/components/canvas/react-flow-canvas.tsx
@src/stores/canvas-store.ts
@src/hooks/use-canvas-autosave.ts
@src/actions/drawing-actions.ts
@src/lib/drawing/simplify.ts
@src/lib/drawing/types.ts
@src/providers/drawing-store-provider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire save flow (EzyDraw modal save → server action → canvas node)</name>
  <files>
    src/components/ezydraw/ezydraw-modal.tsx
    src/components/canvas/react-flow-canvas.tsx
  </files>
  <action>
**Part A: Update EzyDrawModal props and save handler**

Update `EzyDrawModalProps` to support the complete save flow:
```typescript
export interface EzyDrawModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (result: { pngDataUrl: string; elements: DrawingElement[] }) => void;
  initialElements?: DrawingElement[];
  drawingId?: string;  // If set, we're re-editing an existing drawing
}
```

Update `handleSave` in EzyDrawModal:
- Export PNG via `exportToPNG(stage, { pixelRatio: 2 })`
- Get current elements from store using `stageRef.current` — actually, elements come from the DrawingStoreProvider. The modal needs to access the drawing store to get current elements. Use a helper component or lift the save logic.

**Approach**: Create a small inner component `EzyDrawSaveHandler` that lives inside `DrawingStoreProvider` and can access `useDrawingStore`. This component exposes a save callback via ref that the parent uses.

Alternatively (simpler): pass a `getElements` function from the DrawingStoreProvider context. The existing `getSnapshot` action on the drawing store returns the current elements.

**Simplest approach**: The `EzyDrawModal` already wraps children in `DrawingStoreProvider`. Add a `SaveBridge` inner component that:
1. Uses `useDrawingStore(s => s.getSnapshot)` to access elements
2. On save, calls `onSave({ pngDataUrl, elements: getSnapshot() })`

Actually, looking at the existing code more carefully, the `handleSave` in EzyDrawModal already calls `stageRef.current?.getStage()`. We can add a `useDrawingStoreApi()` call inside the inner `DrawingStoreProvider` scope. BUT the `handleSave` is defined OUTSIDE the provider.

**Best approach**: Move the save handler into a child component that lives inside the DrawingStoreProvider:

```typescript
function EzyDrawContent({ stageRef, onSave, onCancel }: {
  stageRef: React.RefObject<EzyDrawStageHandle | null>;
  onSave: (result: { pngDataUrl: string; elements: DrawingElement[] }) => void;
  onCancel: () => void;
}) {
  const getSnapshot = useDrawingStore(s => s.getSnapshot);

  const handleSave = () => {
    const stage = stageRef.current?.getStage();
    if (!stage) return;
    const pngDataUrl = exportToPNG(stage, { pixelRatio: 2 });
    const elements = getSnapshot();
    onSave({ pngDataUrl, elements });
  };

  return (
    <div className="flex h-full flex-col">
      <EzyDrawToolbar onSave={handleSave} onCancel={onCancel} />
      <EzyDrawStage ref={stageRef} />
    </div>
  );
}
```

Then `EzyDrawModal` renders `<EzyDrawContent>` inside the `DrawingStoreProvider`.

**Part B: Wire save flow in react-flow-canvas.tsx**

Add state for EzyDraw modal:
```typescript
const [ezyDrawState, setEzyDrawState] = useState<{
  isOpen: boolean;
  drawingId?: string;           // undefined = new drawing, string = re-editing
  initialElements?: DrawingElement[];
} | null>(null);
```

Add a "Draw" button to the toolbar (or handle via existing toolbar — check canvas-toolbar.tsx). For now, add `onOpenDraw` callback to CanvasToolbar props. If toolbar doesn't support it yet, add a simple floating button in the bottom area alongside the save status indicator.

Actually, the simplest approach: Add a "Draw" button to the CanvasToolbar component. Pass an `onOpenDraw?: () => void` prop to CanvasToolbar. When clicked, open EzyDraw with `setEzyDrawState({ isOpen: true })`.

Add `handleDrawingSave` callback:
```typescript
const handleDrawingSave = async (result: { pngDataUrl: string; elements: DrawingElement[] }) => {
  const simplifiedElements = simplifyDrawingElements(result.elements);
  const vectorJson = JSON.stringify(simplifiedElements);

  if (ezyDrawState?.drawingId) {
    // Re-edit: update existing drawing
    const response = await updateDrawing({
      workshopId,
      stepId,
      drawingId: ezyDrawState.drawingId,
      pngBase64: result.pngDataUrl,
      vectorJson,
      width: /* stage width */ 1920,
      height: /* stage height */ 1080,
    });
    if (response.pngUrl) {
      updateDrawingNode(ezyDrawState.drawingId, { imageUrl: response.pngUrl });
    }
  } else {
    // New drawing: save and add to canvas
    const response = await saveDrawing({
      workshopId,
      stepId,
      pngBase64: result.pngDataUrl,
      vectorJson,
      width: 1920,
      height: 1080,
    });
    if (response.drawingId && response.pngUrl) {
      // Place at viewport center
      const center = screenToFlowPosition({
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
      });
      addDrawingNode({
        drawingId: response.drawingId,
        imageUrl: response.pngUrl,
        position: center,
        width: 400,   // Display size on canvas (not full drawing size)
        height: 225,  // 16:9 aspect ratio
      });
    }
  }

  setEzyDrawState(null); // Close modal
};
```

Import `simplifyDrawingElements` from `@/lib/drawing/simplify`.
Import `saveDrawing`, `updateDrawing`, `loadDrawing` from `@/actions/drawing-actions`.
Import `EzyDrawLoader` from `@/components/ezydraw/ezydraw-loader`.
Import `DrawingElement` type from `@/lib/drawing/types`.
Import `addDrawingNode`, `updateDrawingNode`, `drawingNodes` from canvas store.

Render EzyDrawLoader at the bottom of the component JSX:
```tsx
{ezyDrawState?.isOpen && (
  <EzyDrawLoader
    isOpen={true}
    onClose={() => setEzyDrawState(null)}
    onSave={handleDrawingSave}
    initialElements={ezyDrawState.initialElements}
    drawingId={ezyDrawState.drawingId}
  />
)}
```

**Note on EzyDrawLoader:** Since EzyDrawModalProps has changed (onSave signature), the `EzyDrawLoader` component in `ezydraw-loader.tsx` will automatically pick up the new props since it just passes through with `{...props}`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - EzyDrawModal exports updated props with `onSave: (result: { pngDataUrl, elements }) => void`
    - react-flow-canvas.tsx imports saveDrawing, updateDrawing, simplifyDrawingElements
    - handleDrawingSave calls simplifyDrawingElements before saving
    - EzyDrawLoader rendered conditionally when ezyDrawState is set
  </verify>
  <done>
    Save flow complete: EzyDraw save → simplify elements → upload PNG to Blob → store in DB → add DrawingImageNode to canvas. Re-edit save updates existing drawing (new PNG URL, updated vector JSON).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire re-edit flow and autosave integration</name>
  <files>
    src/components/canvas/react-flow-canvas.tsx
    src/hooks/use-canvas-autosave.ts
  </files>
  <action>
**Part A: Wire re-edit flow in react-flow-canvas.tsx**

Update `handleNodeDoubleClick` to detect drawing nodes and trigger re-edit:
```typescript
const handleNodeDoubleClick = useCallback(
  async (_event: React.MouseEvent, node: Node) => {
    // Check if this is a drawing node
    const drawingNode = drawingNodes.find(dn => dn.id === node.id);
    if (drawingNode) {
      // Load vector JSON from server
      const drawing = await loadDrawing({
        workshopId,
        stepId,
        drawingId: drawingNode.drawingId,
      });
      if (drawing) {
        const elements: DrawingElement[] = JSON.parse(drawing.vectorJson);
        setEzyDrawState({
          isOpen: true,
          drawingId: drawingNode.drawingId,
          initialElements: elements,
        });
      }
      return; // Don't enter postIt edit mode
    }

    // Existing postIt edit behavior
    setEditingNodeId(node.id);
  },
  [drawingNodes, workshopId, stepId]
);
```

This replaces the existing `handleNodeDoubleClick` which was:
```typescript
const handleNodeDoubleClick = useCallback(
  (_event: React.MouseEvent, node: Node) => {
    setEditingNodeId(node.id);
  },
  []
);
```

Import `loadDrawing` from `@/actions/drawing-actions` (should already be imported from Task 1).

**Part B: Update autosave to include drawingNodes**

Read `src/hooks/use-canvas-autosave.ts` first to understand the current pattern. It likely watches `postIts` and `gridColumns` from canvas store and calls `saveCanvasState` periodically.

Update the autosave hook to also include `drawingNodes`:
1. Add `drawingNodes` to the store selectors being watched
2. Add `drawingNodes` to the data passed to `saveCanvasState`

Update `saveCanvasState` in `src/actions/canvas-actions.ts` if needed — but actually, since `saveCanvasState` already stores the canvas state under `_canvas` key as an object, we just need to ensure drawingNodes is included in that object. The function signature accepts `canvasState: { postIts: PostIt[]; gridColumns?: GridColumn[] }` — update the type to include `drawingNodes?: DrawingNode[]`.

Actually, checking the autosave hook is important. If it calls `saveCanvasState({ postIts, gridColumns })`, we just add `drawingNodes` to that object. Update the `saveCanvasState` server action type to accept `drawingNodes` as an optional field.

**Changes to `src/actions/canvas-actions.ts`** (if needed, add to files list):
- Update `canvasState` parameter type to include `drawingNodes?: DrawingNode[]`
- Import `DrawingNode` from canvas-store

**Changes to `use-canvas-autosave.ts`:**
- Subscribe to `drawingNodes` from canvas store
- Include in autosave payload: `{ postIts, gridColumns, drawingNodes }`

**Also update `loadCanvasState`** in canvas-actions.ts to return drawingNodes if present.

**Note on drawing node positions**: Drawing node positions on the ReactFlow canvas are stored in the canvas-store drawingNodes (persisted via autosave). The actual drawing content (PNG + vector JSON) is stored separately in stepArtifacts.drawings[]. This separation means:
- Moving a drawing node on canvas only triggers autosave (lightweight position update)
- Editing a drawing triggers saveDrawing/updateDrawing (heavyweight PNG upload)
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - Double-clicking a drawing node calls loadDrawing and opens EzyDraw modal with initialElements
    - Double-clicking a postIt node still enters text edit mode (no regression)
    - Autosave payload includes drawingNodes
    - loadCanvasState returns drawingNodes if present
  </verify>
  <done>
    Re-edit flow works: double-click drawing node → load vector JSON → parse to DrawingElement[] → open EzyDraw with initialElements. Autosave includes drawing node positions. Canvas state round-trip preserves both postIts and drawingNodes.
  </done>
</task>

</tasks>

<verification>
- Full save flow: Open EzyDraw → draw → save → PNG uploaded to Blob → vector JSON stored → DrawingImageNode appears on canvas
- Full re-edit flow: Double-click DrawingImageNode → vector JSON loaded → elements parsed → EzyDraw opens with drawing → save updates existing record
- Autosave: Moving a drawing node on canvas triggers autosave with updated position
- PostIt behavior: All existing postIt interactions (create, edit, drag, delete) unchanged
- `npx tsc --noEmit` passes with zero errors
</verification>

<success_criteria>
Complete end-to-end drawing lifecycle working: create → display → re-edit → update. Drawing node positions persist via autosave. No regressions to existing canvas functionality.
</success_criteria>

<output>
After completion, create `.planning/phases/26-drawing-canvas-integration/26-03-SUMMARY.md`
</output>
