---
phase: 22-dynamic-grid-structure
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - src/components/canvas/editable-column-header.tsx
  - src/components/canvas/add-column-button.tsx
  - src/components/dialogs/delete-column-dialog.tsx
  - src/components/canvas/grid-overlay.tsx
  - src/components/canvas/react-flow-canvas.tsx
autonomous: true

must_haves:
  truths:
    - "User can click +Add Stage button and type a name to create a new column that appears in the grid"
    - "User can click a column header label to inline-edit it, press Enter to save or Escape to cancel"
    - "User can click a delete button on a column header to remove the column, seeing a confirmation dialog when cards exist"
    - "Cards in a deleted column automatically migrate to the adjacent column (left preferred, then right)"
    - "Column additions, edits, and deletions persist via auto-save and participate in undo/redo"
    - "Maximum 12 columns enforced — +Add Stage button disabled or hidden beyond limit"
  artifacts:
    - path: "src/components/canvas/editable-column-header.tsx"
      provides: "Inline-editable column header with controlled input, Enter/Escape handlers"
      contains: "EditableColumnHeader"
    - path: "src/components/canvas/add-column-button.tsx"
      provides: "+Add Stage button with inline name input"
      contains: "AddColumnButton"
    - path: "src/components/dialogs/delete-column-dialog.tsx"
      provides: "Confirmation dialog for column deletion with card migration preview"
      contains: "DeleteColumnDialog"
    - path: "src/components/canvas/grid-overlay.tsx"
      provides: "Dynamic column rendering from store state, foreignObject-based headers with edit/delete"
      contains: "foreignObject"
    - path: "src/components/canvas/react-flow-canvas.tsx"
      provides: "Grid overlay wired to dynamic gridColumns, initialization of gridColumns from stepConfig"
      contains: "gridColumns"
  key_links:
    - from: "src/components/canvas/grid-overlay.tsx"
      to: "src/stores/canvas-store.ts"
      via: "useCanvasStore selector for gridColumns"
      pattern: "useCanvasStore.*gridColumns"
    - from: "src/components/canvas/editable-column-header.tsx"
      to: "src/stores/canvas-store.ts"
      via: "updateGridColumn action passed as onSave prop"
      pattern: "onSave"
    - from: "src/components/canvas/add-column-button.tsx"
      to: "src/stores/canvas-store.ts"
      via: "addGridColumn action"
      pattern: "addGridColumn"
    - from: "src/components/dialogs/delete-column-dialog.tsx"
      to: "src/stores/canvas-store.ts"
      via: "removeGridColumn action called on confirm"
      pattern: "onConfirm"
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/lib/canvas/grid-layout.ts"
      via: "Dynamic gridConfig construction using store gridColumns"
      pattern: "gridColumns.*gridConfig"
---

<objective>
Build the column management UI: editable column headers, +Add Stage button, delete confirmation dialog, and wire everything into the grid overlay so users can dynamically add, edit, and remove journey map stage columns.

Purpose: This completes DCOL-01 (add columns), DCOL-02 (remove with migration), and DCOL-03 (inline edit). The grid overlay transitions from rendering static columns to rendering dynamic, user-controlled columns from the canvas store.

Output: Fully interactive column headers with inline editing, add button at right edge, delete button on hover, confirmation dialog for columns with cards, card migration to adjacent column on delete.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-dynamic-grid-structure/22-RESEARCH.md
@.planning/phases/22-dynamic-grid-structure/22-01-SUMMARY.md
@src/stores/canvas-store.ts
@src/lib/canvas/grid-layout.ts
@src/components/canvas/grid-overlay.tsx
@src/components/canvas/react-flow-canvas.tsx
@src/components/dialogs/reset-step-dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create column UI components (editable header, add button, delete dialog)</name>
  <files>
    src/components/canvas/editable-column-header.tsx
    src/components/canvas/add-column-button.tsx
    src/components/dialogs/delete-column-dialog.tsx
  </files>
  <action>
**editable-column-header.tsx** — Controlled input inline editing component:

```
'use client';
```

Props: `{ label: string; onSave: (newLabel: string) => void; className?: string }`

State: `isEditing` (boolean), `editValue` (string, initialized from label prop).

Behavior:
- Display mode: Render label text in a `<div>` with `onClick={() => setIsEditing(true)}`. Style: `px-2 py-0.5 text-xs font-semibold cursor-pointer hover:bg-gray-100/80 hover:rounded transition-colors text-gray-500 truncate max-w-[140px]`.
- Edit mode: Render `<input>` with `ref={inputRef}` auto-focused and text selected via useEffect. Style: `nodrag nopan px-1 py-0.5 text-xs font-semibold border-b-2 border-blue-500 bg-white/90 outline-none w-[140px]`. Max length 30.
- `handleSave`: Trim value. If non-empty and different from label, call `onSave(trimmed)`. If empty, revert to original label. Set isEditing false.
- `onKeyDown`: Enter -> handleSave, Escape -> revert and close.
- `onBlur`: handleSave.
- Sync editValue from label prop changes: `useEffect(() => { if (!isEditing) setEditValue(label); }, [label, isEditing]);`

**add-column-button.tsx** — +Add Stage button with inline name input:

```
'use client';
```

Props: `{ onAdd: (label: string) => void; disabled?: boolean }`

State: `isAdding` (boolean), `newColumnLabel` (string).

Behavior:
- Default state: Render a button with PlusCircle icon (from lucide-react) and text "Add Stage". Style: `flex items-center gap-1 text-xs text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded px-2 py-1 transition-colors`. If `disabled`, show muted style and tooltip "Maximum 12 stages".
- Adding state: Render an `<input>` with `autoFocus`, placeholder "Stage name...", maxLength 30. Style similar to editable header input. On Enter or onBlur: if trimmed value non-empty, call `onAdd(trimmed)`, reset state. On Escape: cancel and reset.
- After successful add, reset `newColumnLabel` to '' and `isAdding` to false.

**delete-column-dialog.tsx** — Confirmation dialog following reset-step-dialog.tsx pattern:

```
'use client';
```

Import Dialog/DialogContent/DialogDescription/DialogFooter/DialogHeader/DialogTitle from '@/components/ui/dialog' and Button from '@/components/ui/button'.

Props:
```typescript
{
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void;
  columnLabel: string;
  affectedCardCount: number;
  migrationTarget: string | null; // Adjacent column label, or null if last column
}
```

Render:
- Title: `Delete "{columnLabel}" column?`
- Description varies by affectedCardCount:
  - 0 cards: "This column is empty and can be safely removed."
  - >0 cards with migrationTarget: "This column contains {N} card(s). Cards will be moved to **{migrationTarget}**."
  - >0 cards without migrationTarget: "This column contains {N} card(s). Cards will lose their column assignment."
- Footer: Cancel button (variant="outline") and Delete Column button (variant="destructive"). On delete click: call onConfirm(), then onOpenChange(false).

Follow the exact Dialog pattern from reset-step-dialog.tsx.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors. Verify all three files exist. Verify EditableColumnHeader, AddColumnButton, DeleteColumnDialog are exported.
  </verify>
  <done>
Three new components created: EditableColumnHeader (controlled input, Enter/Escape/blur handling), AddColumnButton (PlusCircle + inline input), DeleteColumnDialog (shadcn Dialog with migration preview). All follow existing codebase patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire dynamic columns into grid overlay and canvas</name>
  <files>
    src/components/canvas/grid-overlay.tsx
    src/components/canvas/react-flow-canvas.tsx
  </files>
  <action>
**grid-overlay.tsx** — Major refactor to render dynamic columns from store with interactive headers:

1. Add imports:
```typescript
import { useCanvasStore } from '@/providers/canvas-store-provider';
import { EditableColumnHeader } from './editable-column-header';
import { PlusCircle, X } from 'lucide-react';
import type { GridColumn } from '@/stores/canvas-store';
```

2. Extend GridOverlayProps:
```typescript
interface GridOverlayProps {
  config: GridConfig;
  highlightedCell?: CellCoordinate | null;
  onDeleteColumn?: (columnId: string, columnLabel: string, affectedCardCount: number, migrationTarget: string | null) => void;
}
```

3. Inside the component, subscribe to store state:
```typescript
const gridColumns = useCanvasStore((s) => s.gridColumns);
const postIts = useCanvasStore((s) => s.postIts);
const updateGridColumn = useCanvasStore((s) => s.updateGridColumn);
const addGridColumn = useCanvasStore((s) => s.addGridColumn);
```

4. Build the effective columns array: Use `gridColumns` if it has entries, otherwise fall back to `config.columns` (backward compat for non-dynamic steps). This is the array used for ALL column position calculations.
```typescript
const effectiveColumns = gridColumns.length > 0 ? gridColumns : config.columns;
```

5. Replace all `config.columns` references in position calculations with `effectiveColumns`.

6. Replace column header rendering section. Instead of SVG `<text>` elements, use `<foreignObject>` to embed HTML components:
```tsx
{effectiveColumns.map((col, index) => {
  const colLeft = colXPositions[index];
  const colRight = colXPositions[index + 1];
  const colWidth = colRight - colLeft;
  const colMidpoint = colLeft + colWidth / 2;
  const headerPos = toScreen(colMidpoint, config.origin.y - 30);
  const headerWidth = Math.max(160, colWidth * zoom);

  // Count cards in this column for delete confirmation
  const cardsInColumn = postIts.filter(p => p.cellAssignment?.col === col.id).length;

  // Find adjacent column for migration target
  const leftAdjacentLabel = effectiveColumns[index - 1]?.label || null;
  const rightAdjacentLabel = effectiveColumns[index + 1]?.label || null;
  const migrationTarget = leftAdjacentLabel || rightAdjacentLabel;

  return (
    <foreignObject
      key={col.id}
      x={headerPos.x - headerWidth / 2}
      y={headerPos.y - 12}
      width={headerWidth}
      height={28}
      className="pointer-events-auto overflow-visible"
    >
      <div className="flex items-center justify-center gap-0.5 group">
        <EditableColumnHeader
          label={col.label}
          onSave={(newLabel) => updateGridColumn(col.id, { label: newLabel })}
        />
        {effectiveColumns.length > 1 && (
          <button
            onClick={() => onDeleteColumn?.(col.id, col.label, cardsInColumn, migrationTarget)}
            className="opacity-0 group-hover:opacity-100 p-0.5 hover:bg-red-100 rounded transition-opacity"
            title="Delete column"
          >
            <X className="h-3 w-3 text-red-500" />
          </button>
        )}
      </div>
    </foreignObject>
  );
})}
```

7. Add the +Add Stage button at the right edge of the column headers. After the column headers loop, render:
```tsx
{/* +Add Stage button after last column */}
{(() => {
  const lastColRight = colXPositions[colXPositions.length - 1];
  const addButtonPos = toScreen(lastColRight + 30, config.origin.y - 30);
  const MAX_COLUMNS = 12;
  return (
    <foreignObject
      x={addButtonPos.x}
      y={addButtonPos.y - 10}
      width={120}
      height={28}
      className="pointer-events-auto overflow-visible"
    >
      <button
        onClick={() => {
          if (effectiveColumns.length < MAX_COLUMNS) {
            addGridColumn(`Stage ${effectiveColumns.length + 1}`);
          }
        }}
        disabled={effectiveColumns.length >= MAX_COLUMNS}
        className="flex items-center gap-1 text-xs text-gray-400 hover:text-gray-600 hover:bg-gray-100/80 rounded px-2 py-1 transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
        title={effectiveColumns.length >= MAX_COLUMNS ? 'Maximum 12 stages' : 'Add a new stage column'}
      >
        <PlusCircle className="h-3.5 w-3.5" />
        Add Stage
      </button>
    </foreignObject>
  );
})()}
```

NOTE on the SVG pointer-events: The parent SVG has `pointer-events-none`. The foreignObject elements need `pointer-events-auto` class to receive clicks. This is the standard React + SVG interactive overlay pattern.

**react-flow-canvas.tsx** — Initialize gridColumns from config and wire delete dialog:

1. Add imports:
```typescript
import { DeleteColumnDialog } from '@/components/dialogs/delete-column-dialog';
import type { GridColumn } from '@/stores/canvas-store';
import type { GridConfig } from '@/lib/canvas/grid-layout';
```

2. Add store selectors for grid column actions:
```typescript
const gridColumns = useCanvasStore((s) => s.gridColumns);
const setGridColumns = useCanvasStore((s) => s.setGridColumns);
const removeGridColumn = useCanvasStore((s) => s.removeGridColumn);
```

3. Initialize gridColumns from stepConfig on mount (when store has empty gridColumns but step has gridConfig). Add a useEffect:
```typescript
useEffect(() => {
  if (stepConfig.hasGrid && stepConfig.gridConfig && gridColumns.length === 0) {
    // Seed dynamic columns from static step config (first load only)
    const initialColumns: GridColumn[] = stepConfig.gridConfig.columns.map(col => ({
      id: col.id,
      label: col.label,
      width: col.width,
    }));
    setGridColumns(initialColumns);
  }
}, [stepConfig, gridColumns.length, setGridColumns]);
```

4. Build a dynamic gridConfig that uses store columns instead of static config columns. This is what gets passed to grid-related functions:
```typescript
const dynamicGridConfig = useMemo<GridConfig | undefined>(() => {
  if (!stepConfig.hasGrid || !stepConfig.gridConfig || gridColumns.length === 0) return undefined;
  return {
    ...stepConfig.gridConfig,
    columns: gridColumns,
  };
}, [stepConfig, gridColumns]);
```

5. Update ALL references to `stepConfig.gridConfig` in the component to use `dynamicGridConfig` instead. This includes:
   - `createPostItAtPosition` — use `dynamicGridConfig` for snapToCell and positionToCell calls
   - `handleToolbarAdd` — use `dynamicGridConfig` for snapToCell and positionToCell calls
   - `handleNodesChange` — use `dynamicGridConfig` for snapToCell and positionToCell calls
   - `handleNodeDrag` — use `dynamicGridConfig` for positionToCell call
   - `handleInit` — check `dynamicGridConfig` instead of `stepConfig.gridConfig`
   - GridOverlay rendering — pass `dynamicGridConfig` as config prop

   In all locations, guard with `if (stepConfig.hasGrid && dynamicGridConfig)` instead of `if (stepConfig.hasGrid && stepConfig.gridConfig)`.

6. Add delete column dialog state:
```typescript
const [deleteColumnDialog, setDeleteColumnDialog] = useState<{
  open: boolean;
  columnId: string;
  columnLabel: string;
  affectedCardCount: number;
  migrationTarget: string | null;
} | null>(null);
```

7. Add delete column handler (passed to GridOverlay):
```typescript
const handleDeleteColumn = useCallback(
  (columnId: string, columnLabel: string, affectedCardCount: number, migrationTarget: string | null) => {
    if (affectedCardCount === 0) {
      // Empty column — delete immediately without dialog
      if (dynamicGridConfig) {
        removeGridColumn(columnId, dynamicGridConfig);
      }
    } else {
      // Has cards — show confirmation dialog
      setDeleteColumnDialog({
        open: true,
        columnId,
        columnLabel,
        affectedCardCount,
        migrationTarget,
      });
    }
  },
  [removeGridColumn, dynamicGridConfig]
);

const handleConfirmDelete = useCallback(() => {
  if (deleteColumnDialog && dynamicGridConfig) {
    removeGridColumn(deleteColumnDialog.columnId, dynamicGridConfig);
    setDeleteColumnDialog(null);
  }
}, [deleteColumnDialog, removeGridColumn, dynamicGridConfig]);
```

8. Pass `onDeleteColumn={handleDeleteColumn}` to GridOverlay.

9. Render DeleteColumnDialog in the JSX (after the ColorPicker/context menu section, before the empty state hint):
```tsx
{deleteColumnDialog && (
  <DeleteColumnDialog
    open={deleteColumnDialog.open}
    onOpenChange={(open) => {
      if (!open) setDeleteColumnDialog(null);
    }}
    onConfirm={handleConfirmDelete}
    columnLabel={deleteColumnDialog.columnLabel}
    affectedCardCount={deleteColumnDialog.affectedCardCount}
    migrationTarget={deleteColumnDialog.migrationTarget}
  />
)}
```
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors. Run `npm run build` — build succeeds. Verify grid-overlay.tsx imports EditableColumnHeader. Verify react-flow-canvas.tsx imports DeleteColumnDialog. Verify dynamicGridConfig is used instead of stepConfig.gridConfig for all grid operations. Verify gridColumns initialization useEffect exists.
  </verify>
  <done>
GridOverlay renders dynamic columns from store with foreignObject-based interactive headers (inline edit + delete button on hover + Add Stage button at right edge). ReactFlowCanvas initializes gridColumns from step config on first load, constructs dynamicGridConfig from store state, passes it to all grid operations. Delete column dialog shows card migration preview for non-empty columns, skips dialog for empty columns. Maximum 12 columns enforced. All column operations persist via auto-save and participate in undo/redo.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds (SSR safety)
- Clicking a column header label enters inline edit mode
- Pressing Enter in edit mode saves the new label
- Pressing Escape reverts to original label
- +Add Stage button creates a new column with default name
- Delete button (X) appears on column header hover
- Clicking delete on empty column removes immediately
- Clicking delete on column with cards shows confirmation dialog
- Confirming deletion migrates cards to adjacent column
- Maximum 12 columns — Add Stage disabled beyond limit
- Undo (Cmd+Z) reverts column add/remove operations
</verification>

<success_criteria>
1. User can add columns via +Add Stage button with a name (DCOL-01)
2. User can inline-edit column headers with Enter/Escape/blur handling (DCOL-03)
3. User can remove columns with confirmation dialog showing affected card count and migration target (DCOL-02)
4. Cards in deleted columns migrate to adjacent column automatically (DCOL-02)
5. Column operations complete with smooth UI feedback, under 500ms
6. Maximum 12 columns enforced
7. All operations persist via auto-save and undo/redo
8. TypeScript compilation and production build both pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-dynamic-grid-structure/22-02-SUMMARY.md`
</output>
