---
phase: 08-ai-facilitation-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/workshop-steps-arc.ts
  - src/db/schema/index.ts
  - src/lib/ai/conversation-state.ts
autonomous: true

must_haves:
  truths:
    - "Arc phase is tracked per workshop step in the database"
    - "New conversations default to 'orient' arc phase"
    - "Arc phase can be read and updated for any workshop step"
    - "Arc phase persists across server restarts and page refreshes"
  artifacts:
    - path: "src/lib/ai/conversation-state.ts"
      provides: "Arc phase read/write/transition functions"
      exports: ["getCurrentArcPhase", "transitionArcPhase"]
      min_lines: 30
  key_links:
    - from: "src/lib/ai/conversation-state.ts"
      to: "src/db/schema"
      via: "Drizzle query on workshopSteps"
      pattern: "db\\.(select|update).*workshopSteps"
    - from: "src/lib/ai/conversation-state.ts"
      to: "src/lib/ai/prompts/arc-phases.ts"
      via: "ArcPhase type import"
      pattern: "import.*ArcPhase"
---

<objective>
Add arc phase tracking to the database and create service functions to read/update the current conversational arc phase per workshop step.

Purpose: The AI needs to know which arc phase (Orient, Gather, Synthesize, Refine, Validate, Complete) the conversation is in. Without database-backed state, the AI would lose track of the phase between requests and exhibit "arc phase whiplash" (jumping between phases erratically). This is a key anti-pattern identified in research.

Output: Database column for arc phase on workshop_steps table, service layer for reading/updating arc phase.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ai-facilitation-engine/08-RESEARCH.md
@src/db/schema/steps.ts
@src/lib/ai/chat-config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add arcPhase column to workshopSteps table</name>
  <files>src/db/schema/steps.ts</files>
  <action>
Modify `src/db/schema/steps.ts` to add an `arcPhase` column to the `workshopSteps` table:

- Add column: `arcPhase: text('arc_phase', { enum: ['orient', 'gather', 'synthesize', 'refine', 'validate', 'complete'] }).notNull().default('orient').$type<'orient' | 'gather' | 'synthesize' | 'refine' | 'validate' | 'complete'>()`
- Place the column after `status` and before `output` for logical grouping
- Default to 'orient' so new/existing workshop steps start in the Orient phase
- This is a non-breaking change: existing rows get 'orient' default, no data migration needed

After modifying the schema, run `npm run db:push:dev` (or equivalent Drizzle push command) to apply the column to the Neon database. If the project uses `npx drizzle-kit push`, use that instead.

Do NOT create a separate schema file for this -- it belongs on the existing workshopSteps table alongside status.
  </action>
  <verify>
`npx tsc --noEmit` passes. Run the DB push command and confirm it completes without errors. The arc_phase column should appear in the workshop_steps table.
  </verify>
  <done>
workshopSteps table has arcPhase column with enum values for all 6 arc phases, defaulting to 'orient'. Database schema is synced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create conversation state service for arc phase tracking</name>
  <files>src/lib/ai/conversation-state.ts</files>
  <action>
Create `src/lib/ai/conversation-state.ts`:

Import ArcPhase type from `@/lib/ai/prompts/arc-phases` (Plan 01 creates this file -- if it doesn't exist yet, define ArcPhase locally as a type alias and add a TODO comment to import from arc-phases.ts once available).

Export `async function getCurrentArcPhase(workshopId: string, stepId: string): Promise<ArcPhase>`:
- Query workshopSteps table where workshopId and stepId match
- Return the arcPhase column value
- If no row found, return 'orient' as default
- Use Drizzle `eq` and `and` for the where clause

Export `async function transitionArcPhase(workshopId: string, stepId: string, newPhase: ArcPhase): Promise<void>`:
- Update workshopSteps.arcPhase where workshopId and stepId match
- Also update the updatedAt timestamp
- No return value needed (fire-and-forget from the chat API's perspective, but awaited for reliability)

These functions use workshopId + stepId (not sessionId) because arc phase is per workshop-step, not per session. A user resuming a workshop should continue from the same arc phase.

Do NOT add complex state machine logic here (e.g., transition validation, phase history). Keep it simple read/write. The AI decides when to transition based on system prompt instructions -- the database just tracks the current state.
  </action>
  <verify>
`npx tsc --noEmit` passes. Both exported functions are properly typed. Grep confirms imports from Drizzle schema and ArcPhase type.
  </verify>
  <done>
getCurrentArcPhase returns the arc phase for a workshop step (defaulting to 'orient'). transitionArcPhase updates it. Both functions use Drizzle queries against workshopSteps table.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- workshopSteps table schema includes arcPhase column
- Database migration/push applied successfully
- conversation-state.ts exports getCurrentArcPhase and transitionArcPhase
- No circular dependencies introduced
</verification>

<success_criteria>
- Arc phase column exists on workshopSteps table with proper enum constraint and 'orient' default
- Service layer can read and write arc phase per workshop step
- Existing data is not broken (default 'orient' applied to existing rows)
- Database schema is synced to Neon
</success_criteria>

<output>
After completion, create `.planning/phases/08-ai-facilitation-engine/08-02-SUMMARY.md`
</output>
