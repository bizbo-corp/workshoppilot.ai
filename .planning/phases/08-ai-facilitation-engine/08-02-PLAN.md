---
phase: 08-ai-facilitation-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/steps.ts
  - src/lib/ai/conversation-state.ts
autonomous: true

must_haves:
  truths:
    - "Arc phase is tracked per workshop step in the database"
    - "New conversations default to 'orient' arc phase"
    - "Arc phase can be read and updated for any workshop step"
    - "Arc phase persists across server restarts and page refreshes"
  artifacts:
    - path: "src/lib/ai/conversation-state.ts"
      provides: "Arc phase read/write/transition functions"
      exports: ["getCurrentArcPhase", "transitionArcPhase"]
      min_lines: 30
  key_links:
    - from: "src/lib/ai/conversation-state.ts"
      to: "src/db/schema"
      via: "Drizzle query on workshopSteps"
      pattern: "db\\.(select|update).*workshopSteps"
---

<objective>
Add arc phase tracking to the database and create service functions to read/update the current conversational arc phase per workshop step.

Purpose: The AI needs to know which arc phase (Orient, Gather, Synthesize, Refine, Validate, Complete) the conversation is in. Without database-backed state, the AI would lose track of the phase between requests and exhibit "arc phase whiplash" (jumping between phases erratically). This is a key anti-pattern identified in research.

Output: Database column for arc phase on workshop_steps table, service layer for reading/updating arc phase.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ai-facilitation-engine/08-RESEARCH.md
@src/db/schema/steps.ts
@src/lib/ai/chat-config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add arcPhase column to workshopSteps table</name>
  <files>src/db/schema/steps.ts</files>
  <action>
Modify `src/db/schema/steps.ts` to add an `arcPhase` column to the `workshopSteps` table:

- Add column: `arcPhase: text('arc_phase', { enum: ['orient', 'gather', 'synthesize', 'refine', 'validate', 'complete'] }).notNull().default('orient').$type<'orient' | 'gather' | 'synthesize' | 'refine' | 'validate' | 'complete'>()`
- Place the column after `status` and before `output` for logical grouping
- Default to 'orient' so new/existing workshop steps start in the Orient phase
- This is a non-breaking change: existing rows get 'orient' default, no data migration needed

After modifying the schema, run `npm run db:push:dev` to apply the column to the Neon database.

Do NOT create a separate schema file for this -- it belongs on the existing workshopSteps table alongside status.
  </action>
  <verify>
`npx tsc --noEmit` passes. Run `npm run db:push:dev` and confirm the command exits with code 0 and outputs confirmation that changes were applied (or "No changes detected" if already synced). Verify by checking the Drizzle schema snapshot or running `npm run db:push:dev` a second time to confirm "No changes detected".
  </verify>
  <done>
workshopSteps table has arcPhase column with enum values for all 6 arc phases, defaulting to 'orient'. Database schema is synced via `npm run db:push:dev`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create conversation state service for arc phase tracking</name>
  <files>src/lib/ai/conversation-state.ts</files>
  <action>
Create `src/lib/ai/conversation-state.ts`:

Define ArcPhase locally as a type alias in this file:
```
export type ArcPhase = 'orient' | 'gather' | 'synthesize' | 'refine' | 'validate' | 'complete';
```
This avoids a dependency on `src/lib/ai/prompts/arc-phases.ts` (which Plan 08-01 creates and may not exist yet since both plans are Wave 1). Plan 08-01's arc-phases.ts will define the same type -- the prompt assembly layer (Plan 08-03) will reconcile these into a single canonical import. For now, keeping it local ensures this plan can execute independently.

Export `async function getCurrentArcPhase(workshopId: string, stepId: string): Promise<ArcPhase>`:
- Query workshopSteps table where workshopId and stepId match
- Return the arcPhase column value
- If no row found, return 'orient' as default
- Use Drizzle `eq` and `and` for the where clause

Export `async function transitionArcPhase(workshopId: string, stepId: string, newPhase: ArcPhase): Promise<void>`:
- Update workshopSteps.arcPhase where workshopId and stepId match
- Also update the updatedAt timestamp
- No return value needed (fire-and-forget from the chat API's perspective, but awaited for reliability)

These functions use workshopId + stepId (not sessionId) because arc phase is per workshop-step, not per session. A user resuming a workshop should continue from the same arc phase.

Do NOT add complex state machine logic here (e.g., transition validation, phase history). Keep it simple read/write. The AI decides when to transition based on system prompt instructions -- the database just tracks the current state.
  </action>
  <verify>
`npx tsc --noEmit` passes. Both exported functions are properly typed. Grep confirms imports from Drizzle schema. Grep confirms ArcPhase type is defined locally (not imported from arc-phases.ts).
  </verify>
  <done>
getCurrentArcPhase returns the arc phase for a workshop step (defaulting to 'orient'). transitionArcPhase updates it. Both functions use Drizzle queries against workshopSteps table. ArcPhase is defined locally to avoid Wave 1 race condition with Plan 08-01.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- workshopSteps table schema includes arcPhase column
- `npm run db:push:dev` completes successfully (exit code 0)
- conversation-state.ts exports getCurrentArcPhase and transitionArcPhase
- ArcPhase type is defined locally in conversation-state.ts (no import from arc-phases.ts)
- No circular dependencies introduced
</verification>

<success_criteria>
- Arc phase column exists on workshopSteps table with proper enum constraint and 'orient' default
- Service layer can read and write arc phase per workshop step
- Existing data is not broken (default 'orient' applied to existing rows)
- Database schema is synced to Neon via `npm run db:push:dev`
</success_criteria>

<output>
After completion, create `.planning/phases/08-ai-facilitation-engine/08-02-SUMMARY.md`
</output>
