---
phase: 11-discovery-steps-1-4
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/workshop/step-navigation.tsx
  - src/actions/workshop-actions.ts
  - src/app/api/chat/arc-transition/route.ts
  - src/lib/ai/conversation-state.ts
  - src/components/workshop/chat-panel.tsx
autonomous: true

must_haves:
  truths:
    - "When user advances from Step 1 to Step 2, a conversation summary is generated for Step 1"
    - "Step 2 AI receives Step 1 summary and artifact in its system prompt"
    - "AI arc phase transitions from orient to gather after initial exchange"
    - "AI arc phase reaches validate before step completion"
  artifacts:
    - path: "src/app/api/chat/arc-transition/route.ts"
      provides: "API endpoint for arc phase transitions"
      exports: ["POST"]
    - path: "src/components/workshop/step-navigation.tsx"
      provides: "Step advance triggers summary generation"
      contains: "complete"
    - path: "src/components/workshop/chat-panel.tsx"
      provides: "Chat panel sends arc transition requests"
      contains: "arc-transition"
  key_links:
    - from: "src/components/workshop/step-navigation.tsx"
      to: "/api/workshops/[workshopId]/steps/[stepId]/complete"
      via: "fetch call before advanceToNextStep"
      pattern: "api/workshops.*complete"
    - from: "src/components/workshop/chat-panel.tsx"
      to: "/api/chat/arc-transition"
      via: "fetch call after AI response"
      pattern: "arc-transition"
---

<objective>
Wire step completion summaries and arc phase transitions so Steps 1-4 produce forward-flowing context and follow the 6-phase conversational arc.

Purpose: Without summary generation on step advance, Steps 2-4 receive no context from prior steps. Without arc transitions, AI stays in "orient" mode forever. Both are critical for the Discovery Steps to function as a connected flow.

Output: Step navigation triggers summary generation; chat responses trigger arc phase transitions; forward context flows between steps.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/workshop/step-navigation.tsx
@src/actions/workshop-actions.ts
@src/app/api/workshops/[workshopId]/steps/[stepId]/complete/route.ts
@src/lib/ai/conversation-state.ts
@src/app/api/chat/route.ts
@src/components/workshop/chat-panel.tsx
@src/lib/context/generate-summary.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire summary generation into step advance flow</name>
  <files>
    src/components/workshop/step-navigation.tsx
    src/actions/workshop-actions.ts
  </files>
  <action>
The current `advanceToNextStep` server action marks the current step as complete but does NOT generate a conversation summary. The summary generation lives in a separate endpoint (`/api/workshops/[workshopId]/steps/[stepId]/complete/route.ts`) that is never called from the navigation flow.

Fix this by calling `generateStepSummary` inside `advanceToNextStep`:

1. In `src/actions/workshop-actions.ts`, update `advanceToNextStep`:
   - Import `generateStepSummary` from `@/lib/context/generate-summary`
   - Import `getStepById` from `@/lib/workshop/step-metadata`
   - After `updateStepStatus(workshopId, currentStepId, 'complete', sessionId)`, find the workshopStepId:
     ```
     const workshopStepResult = await db
       .select({ id: workshopSteps.id })
       .from(workshopSteps)
       .where(and(
         eq(workshopSteps.workshopId, workshopId),
         eq(workshopSteps.stepId, currentStepId)
       ))
       .limit(1);
     ```
   - Call `generateStepSummary(sessionId, workshopStepId, currentStepId, stepName)` wrapped in try/catch (summary failure should NOT block step advance, per Phase 7 decision)
   - Log error if summary generation fails but continue

2. In `src/components/workshop/step-navigation.tsx`, update `handleNext`:
   - The step-navigation currently calls `advanceToNextStep` which will now handle summary generation internally.
   - Also call the step completion endpoint BEFORE advancing to ensure the completion endpoint's summary logic runs:
     ```
     const currentStep = STEPS.find((s) => s.order === currentStepOrder);
     await fetch(`/api/workshops/${workshopId}/steps/${currentStep.id}/complete`, {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({ sessionId }),
     });
     ```
   - Actually, simpler approach: Just integrate summary generation into `advanceToNextStep` server action (approach from item 1 above). Do NOT double-call. The step completion endpoint can remain as a standalone API for future use.
   - Use approach 1 only (server action integration). No changes needed to step-navigation.tsx beyond what already exists.

IMPORTANT: Summary generation must happen synchronously (per Phase 7 decision) but failure must not block step advance.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- `advanceToNextStep` function now imports and calls `generateStepSummary`
- Summary generation is wrapped in try/catch with console.error on failure
  </verify>
  <done>
When user clicks Next to advance from any step, a conversation summary is generated and stored in step_summaries table. Summary failure logs an error but does not prevent step advance.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create arc phase transition API and wire into chat flow</name>
  <files>
    src/app/api/chat/arc-transition/route.ts
    src/components/workshop/chat-panel.tsx
  </files>
  <action>
Arc phase transitions are the mechanism that moves the AI from Orient -> Gather -> Synthesize -> Refine -> Validate -> Complete. The `transitionArcPhase` function exists in `conversation-state.ts` but is never called. The AI always receives `orient` phase instructions.

Implement a simple heuristic-based transition triggered after each AI response:

1. Create `src/app/api/chat/arc-transition/route.ts`:
   - POST endpoint accepting `{ workshopId, stepId, messageCount }`
   - Use a message-count heuristic to determine arc phase:
     - Messages 0-2 (0-1 exchanges): `orient` (AI introduces step)
     - Messages 3-8 (1-4 exchanges): `gather` (AI collects info)
     - Messages 9-14 (4-7 exchanges): `synthesize` (AI drafts output)
     - Messages 15-18 (7-9 exchanges): `refine` (AI helps improve)
     - Messages 19-22 (9-11 exchanges): `validate` (AI checks quality)
     - Messages 23+: `complete` (AI encourages completion)
   - Import `transitionArcPhase` from `@/lib/ai/conversation-state`
   - Import `getCurrentArcPhase` to avoid unnecessary DB writes if phase hasn't changed
   - Only call `transitionArcPhase` if the computed phase differs from current
   - Return `{ arcPhase: newPhase, transitioned: boolean }`
   - This is a best-effort heuristic for MVP. The AI's conversational behavior will naturally align because it gets phase-specific instructions on each request.

2. Update `src/components/workshop/chat-panel.tsx`:
   - After each message exchange completes (when `status` transitions from `streaming` back to `ready`), fire a background request to the arc-transition endpoint:
     ```
     useEffect(() => {
       if (status === 'ready' && messages.length > 0) {
         // Fire-and-forget arc phase transition
         fetch('/api/chat/arc-transition', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({
             workshopId,
             stepId: step.id,
             messageCount: messages.length,
           }),
         }).catch(() => {}); // Ignore errors - non-critical
       }
     }, [status, messages.length]);
     ```
   - This is fire-and-forget. Arc transition failure does not affect chat functionality.
   - The NEXT chat request will pick up the updated arc phase from the database (already wired in chat API route.ts).

Note: This heuristic approach is intentionally simple for MVP. The message-count thresholds can be tuned later. A more sophisticated approach (AI self-reports phase) can be added in future phases.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- `src/app/api/chat/arc-transition/route.ts` exists with POST handler
- ChatPanel includes useEffect that calls arc-transition endpoint
- Arc transition only writes to DB when phase actually changes
  </verify>
  <done>
After each AI response, the arc phase is computed from message count and persisted to the database. The next chat request receives the updated arc phase in its system prompt, causing the AI to shift behavior from Orient through Gather, Synthesize, Refine, Validate, and Complete.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes with zero errors
2. Build: `npm run build` succeeds
3. Code review: `advanceToNextStep` includes summary generation call
4. Code review: Arc transition endpoint exists and uses message-count heuristic
5. Code review: ChatPanel fires arc transition after each AI response
</verification>

<success_criteria>
- Step advance generates conversation summaries (forward context for Steps 2-4)
- Arc phase transitions based on conversation progress
- No regressions in existing chat, navigation, or extraction functionality
- Summary generation failure does not block step advance
- Arc transition failure does not affect chat functionality
</success_criteria>

<output>
After completion, create `.planning/phases/11-discovery-steps-1-4/11-01-SUMMARY.md`
</output>
