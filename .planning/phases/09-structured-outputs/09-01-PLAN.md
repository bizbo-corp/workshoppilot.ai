---
phase: 09-structured-outputs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/schemas/step-schemas.ts
  - src/lib/schemas/index.ts
  - src/lib/context/types.ts
autonomous: true

must_haves:
  truths:
    - "Every step (1-10) has a Zod schema defining its artifact shape"
    - "Schema types are inferred from Zod and available as TypeScript types"
    - "Schemas use .describe() on every field for LLM extraction guidance"
    - "Secondary fields are optional to prevent extraction failures"
  artifacts:
    - path: "src/lib/schemas/step-schemas.ts"
      provides: "Zod schemas for all 10 step artifacts"
      contains: "challengeArtifactSchema"
    - path: "src/lib/schemas/index.ts"
      provides: "Re-exports of all schemas and types"
      exports: ["stepSchemaMap", "getSchemaForStep"]
    - path: "src/lib/context/types.ts"
      provides: "Updated ArtifactRecord as union of step types"
      contains: "StepArtifactMap"
  key_links:
    - from: "src/lib/schemas/step-schemas.ts"
      to: "src/lib/schemas/index.ts"
      via: "re-export"
      pattern: "export.*from.*step-schemas"
    - from: "src/lib/schemas/index.ts"
      to: "src/lib/context/types.ts"
      via: "type import for ArtifactRecord"
      pattern: "StepArtifactMap"
---

<objective>
Define Zod schemas for all 10 design thinking step artifacts with LLM-friendly descriptions, and update the context type system to use step-specific types instead of generic Record.

Purpose: OUT-01 requires each step to produce a typed JSON artifact matching a Zod schema. Schemas are the foundation -- extraction, validation, rendering, and storage all depend on these type definitions.
Output: Step-specific Zod schemas, inferred TypeScript types, schema lookup map, and updated context types.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-structured-outputs/09-RESEARCH.md

@src/lib/workshop/step-metadata.ts
@src/lib/context/types.ts
@src/lib/context/save-artifact.ts
@src/db/schema/step-artifacts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schemas for all 10 step artifacts</name>
  <files>src/lib/schemas/step-schemas.ts, src/lib/schemas/index.ts</files>
  <action>
Create `src/lib/schemas/step-schemas.ts` with Zod schemas for all 10 steps. Use .describe() on EVERY field to guide the LLM during extraction. Keep schemas flat (max 2 levels nesting), limit required fields to core essentials (3-7 per schema), mark secondary fields as .optional().

Schemas to create (use step IDs from step-metadata.ts):

1. **challengeArtifactSchema** (step: 'challenge'):
   - problemStatement: string (required) - "Clear description of the core problem"
   - targetUser: string (required) - "Specific user or stakeholder group"
   - desiredOutcome: string (required) - "Measurable outcome indicating success"
   - hmwStatement: string (required) - "Complete HMW: How might we [action] for [who] so that [outcome]?"
   - altitude: enum ['specific', 'balanced', 'broad'] (optional) - "Scope level"

2. **stakeholderArtifactSchema** (step: 'stakeholder-mapping'):
   - stakeholders: array of objects (required), each with:
     - name: string (required) - "Stakeholder name or role"
     - category: enum ['core', 'direct', 'indirect'] (required) - "Priority level"
     - power: enum ['high', 'medium', 'low'] (required) - "Influence level"
     - interest: enum ['high', 'medium', 'low'] (required) - "Interest level"
     - notes: string (optional) - "Additional context"

3. **userResearchArtifactSchema** (step: 'user-research'):
   - interviewQuestions: array of strings (required, min 3, max 8) - "Open-ended research questions"
   - insights: array of objects (required, min 2), each with:
     - finding: string (required) - "Specific observation or behavior"
     - source: string (optional) - "Which stakeholder type this came from"
     - quote: string (optional) - "Verbatim or representative quote"

4. **senseMakingArtifactSchema** (step: 'sense-making'):
   - themes: array of objects (required, min 2, max 5), each with:
     - name: string (required) - "Theme label"
     - evidence: array of strings (required, min 1) - "Supporting research findings"
   - pains: array of strings (required, min 3, max 5) - "Top pain points with evidence"
   - gains: array of strings (required, min 3, max 5) - "Top desired gains with evidence"

5. **personaArtifactSchema** (step: 'persona'):
   - name: string (required) - "Persona name"
   - age: number (optional, min 18, max 100) - "Age in years"
   - role: string (required) - "Job title or primary role"
   - location: string (optional) - "Geographic location"
   - bio: string (required) - "2-3 sentence background grounded in research"
   - quote: string (required) - "Defining sentence in their voice"
   - goals: array of strings (required, min 2, max 5) - "Primary goals from Step 4 gains"
   - pains: array of strings (required, min 2, max 5) - "Pain points from Step 4 pains"
   - behaviors: array of strings (optional) - "Observable behavior patterns"

6. **journeyMappingArtifactSchema** (step: 'journey-mapping'):
   - personaName: string (required) - "Name of the persona from Step 5"
   - stages: array of objects (required, min 4, max 8), each with:
     - name: string (required) - "Stage name"
     - actions: string (required) - "What the persona does"
     - thoughts: string (required) - "What they think"
     - emotions: string (required) - "How they feel"
     - isDip: boolean (optional, default false) - "Whether this is the critical dip"
   - dipSummary: string (required) - "Description of the critical pain point identified as the dip"

7. **reframeArtifactSchema** (step: 'reframe'):
   - originalHmw: string (required) - "Original HMW from Step 1"
   - insightsApplied: array of strings (required, min 1) - "Key research insights that shifted perspective"
   - refinedHmw: string (required) - "Reframed HMW: How might we [action] for [persona] when [context] so that [outcome]?"
   - evolution: string (optional) - "How understanding evolved from original challenge"

8. **ideationArtifactSchema** (step: 'ideation'):
   - hmwPrompt: string (required) - "The HMW statement from Step 7 used as ideation prompt"
   - ideas: array of objects (required, min 5), each with:
     - title: string (required) - "Idea name"
     - description: string (required) - "Brief description of the idea"
     - category: string (optional) - "Category: tech, service, process, education, etc."
   - topIdeas: array of strings (optional, max 3) - "Titles of the most promising ideas"

9. **conceptArtifactSchema** (step: 'concept'):
   - name: string (required) - "Concept name"
   - elevatorPitch: string (required) - "One-sentence description"
   - usp: string (optional) - "Unique selling proposition"
   - swot: object (required) with:
     - strengths: array of strings (min 1) - "Internal advantages"
     - weaknesses: array of strings (min 1) - "Internal limitations"
     - opportunities: array of strings (min 1) - "External possibilities"
     - threats: array of strings (min 1) - "External risks"
   - feasibility: object (optional) with:
     - technical: enum ['high', 'medium', 'low'] - "Technical feasibility"
     - business: enum ['high', 'medium', 'low'] - "Business feasibility"
     - userDesirability: enum ['high', 'medium', 'low'] - "User desirability"
     - rationale: string (optional) - "Reasoning for feasibility scores"
   - nextSteps: array of strings (optional) - "Recommended next actions"

10. **validateArtifactSchema** (step: 'validate'):
    - userFlow: string (required) - "Text-based user flow from entry to outcome"
    - prdOutline: object (required) with:
      - overview: string (required) - "Overview and objectives"
      - targetUsers: string (required) - "Target users and personas summary"
      - coreFeatures: array of strings (required, min 2) - "MVP core features"
      - userStories: array of strings (optional) - "Key user stories"
      - technicalRequirements: string (optional) - "Technical constraints and requirements"
      - successMetrics: array of strings (optional) - "How to measure success"
    - journeySummary: string (optional) - "Recap of the full 10-step journey"

Export inferred types from each schema using `z.infer<typeof schema>`.

Create `src/lib/schemas/index.ts` that:
- Re-exports all schemas and types from step-schemas.ts
- Creates a `stepSchemaMap` Record mapping step IDs to their Zod schemas: `Record<string, z.ZodType>`
- Exports a `getSchemaForStep(stepId: string)` function that returns the schema or undefined

NOTE: Use Zod v4 syntax (z.object, z.array, z.enum, z.string, z.number, z.boolean). Zod 4 is installed (^4.3.6). Check Zod v4 .describe() usage -- in Zod 4 .describe() may need to be called differently than v3. If .describe() is not available on schema types in Zod 4, use the meta() API or comments instead. Test with: `npx tsc --noEmit` to catch type errors.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors in the new schema files. Verify `getSchemaForStep('challenge')` is defined by grep.
  </verify>
  <done>
All 10 step schemas compile without errors. Each schema has .describe() (or equivalent) on all fields. stepSchemaMap maps all 10 step IDs. getSchemaForStep returns correct schema for each step.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update context types with step-specific artifact types</name>
  <files>src/lib/context/types.ts</files>
  <action>
Update `src/lib/context/types.ts` to replace the generic `ArtifactRecord = Record<string, unknown>` placeholder with step-specific types.

1. Import all step artifact types from `@/lib/schemas`:
   - ChallengeArtifact, StakeholderArtifact, UserResearchArtifact, etc.

2. Create a `StepArtifactMap` type that maps step IDs to their artifact types:
   ```typescript
   export type StepArtifactMap = {
     challenge: ChallengeArtifact;
     'stakeholder-mapping': StakeholderArtifact;
     'user-research': UserResearchArtifact;
     'sense-making': SenseMakingArtifact;
     persona: PersonaArtifact;
     'journey-mapping': JourneyMappingArtifact;
     reframe: ReframeArtifact;
     ideation: IdeationArtifact;
     concept: ConceptArtifact;
     validate: ValidateArtifact;
   };
   ```

3. Create a union type for any artifact: `export type AnyStepArtifact = StepArtifactMap[keyof StepArtifactMap];`

4. Keep the existing `ArtifactRecord = Record<string, unknown>` as-is (don't remove it) since save-artifact.ts and other code still uses it. Add a comment: "Deprecated: Use StepArtifactMap types for new code. Kept for backward compatibility with existing save-artifact.ts."

5. Keep all existing types (ContextTier, StepContext) unchanged.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Verify StepArtifactMap and AnyStepArtifact are exported by grepping the file.
  </verify>
  <done>
StepArtifactMap maps all 10 step IDs to typed artifacts. AnyStepArtifact union type exists. Existing ArtifactRecord preserved for backward compatibility. No type errors in build.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `src/lib/schemas/step-schemas.ts` exports 10 schema objects and 10 type aliases
- `src/lib/schemas/index.ts` exports stepSchemaMap with 10 entries and getSchemaForStep function
- `src/lib/context/types.ts` exports StepArtifactMap and AnyStepArtifact types
- All schemas have .describe() or equivalent metadata on every field
- No existing tests are broken
</verification>

<success_criteria>
- OUT-01 foundation complete: Each step has a typed Zod schema
- Schemas follow research guidelines: flat structure, max 2 levels nesting, secondary fields optional
- Type system is backward-compatible (existing code still works)
- Schema lookup by step ID works for all 10 steps
</success_criteria>

<output>
After completion, create `.planning/phases/09-structured-outputs/09-01-SUMMARY.md`
</output>
