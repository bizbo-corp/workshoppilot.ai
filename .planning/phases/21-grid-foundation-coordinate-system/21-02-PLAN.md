---
phase: 21-grid-foundation-coordinate-system
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/components/canvas/grid-overlay.tsx
  - src/components/canvas/react-flow-canvas.tsx
  - src/lib/workshop/context/canvas-context.ts
autonomous: true

must_haves:
  truths:
    - "User sees 7 fixed swimlane rows with labeled headers on Step 6 (journey-mapping) canvas"
    - "User sees 5 default column headers (Awareness, Consideration, Decision, Purchase, Onboarding) on Step 6 canvas"
    - "Post-it items snap to cell boundaries when dragged and dropped on grid canvas"
    - "Post-it items store cellAssignment metadata (row + col IDs) alongside pixel position after drag"
    - "Grid overlay stays aligned with canvas during pan and zoom at all zoom levels"
    - "Target cell highlights with light blue background when user drags an item over it"
    - "Grid canvas state persists to database via existing auto-save without data loss"
    - "Non-grid steps (Steps 1-5, 7-10) render without grid overlay (no regression)"
  artifacts:
    - path: "src/components/canvas/grid-overlay.tsx"
      provides: "Viewport-aware SVG grid overlay with row labels, column headers, grid lines, and cell highlighting"
      exports: ["GridOverlay"]
    - path: "src/components/canvas/react-flow-canvas.tsx"
      provides: "Canvas component with conditional grid rendering, custom snap, and cell highlighting during drag"
      contains: "GridOverlay"
    - path: "src/lib/workshop/context/canvas-context.ts"
      provides: "AI context assembly for journey-mapping step grouping by row/column"
      exports: ["assembleJourneyMapCanvasContext", "assembleCanvasContextForStep"]
  key_links:
    - from: "src/components/canvas/grid-overlay.tsx"
      to: "src/lib/canvas/grid-layout.ts"
      via: "Imports GridConfig, getCellBounds for cell highlight positioning"
      pattern: "import.*grid-layout"
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/lib/canvas/grid-layout.ts"
      via: "Imports positionToCell and snapToCell for drag handlers"
      pattern: "import.*grid-layout"
    - from: "src/components/canvas/react-flow-canvas.tsx"
      to: "src/components/canvas/grid-overlay.tsx"
      via: "Conditional GridOverlay rendering based on stepConfig.hasGrid"
      pattern: "GridOverlay"
    - from: "src/lib/workshop/context/canvas-context.ts"
      to: "src/stores/canvas-store.ts"
      via: "Reads PostIt cellAssignment field to group by row/column"
      pattern: "cellAssignment"
---

<objective>
Create the grid overlay component, wire grid behavior into ReactFlowCanvas (snap-to-cell, cell highlighting, cell assignment on drag), and add journey-map AI context assembly.

Purpose: This plan delivers the complete user-facing grid experience for Step 6: visible swimlane grid with row/column labels, real-time cell highlighting during drag, snap-to-cell on drop, cell metadata persistence, and AI-readable context grouped by grid position.

Output: GridOverlay component, updated ReactFlowCanvas with grid integration, and journey-map context assembly function.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-grid-foundation-coordinate-system/21-RESEARCH.md
@.planning/phases/21-grid-foundation-coordinate-system/21-01-SUMMARY.md

# Key source files
@src/components/canvas/quadrant-overlay.tsx
@src/components/canvas/react-flow-canvas.tsx
@src/lib/canvas/grid-layout.ts
@src/lib/canvas/step-canvas-config.ts
@src/stores/canvas-store.ts
@src/lib/workshop/context/canvas-context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GridOverlay component with cell highlighting</name>
  <files>src/components/canvas/grid-overlay.tsx</files>
  <action>
Create `src/components/canvas/grid-overlay.tsx` following the QuadrantOverlay pattern (viewport-aware SVG).

**Component signature:**
```typescript
interface GridOverlayProps {
  config: GridConfig;
  highlightedCell?: CellCoordinate | null;
}

export function GridOverlay({ config, highlightedCell }: GridOverlayProps) { ... }
```

**Implementation details:**

1. **Viewport subscription** (same pattern as QuadrantOverlay):
```typescript
import { useStore as useReactFlowStore, type ReactFlowState } from '@xyflow/react';

const viewportSelector = (state: ReactFlowState) => ({
  x: state.transform[0],
  y: state.transform[1],
  zoom: state.transform[2],
});
```

2. **Calculate screen positions for rows and columns** dynamically from config:
   - Accumulate row heights from `config.origin.y` for Y positions
   - Accumulate column widths from `config.origin.x` for X positions
   - Transform to screen coords: `canvasY * zoom + viewportY`

3. **Render SVG elements:**
   - **Row label backgrounds:** Subtle gray rectangle behind each row label for readability
   - **Row labels:** Text elements positioned at left edge (fixed x=10 screen pixels would not pan correctly; instead use `config.origin.x - 10` in canvas coords transformed to screen). Labels should be LEFT of the grid area. Use a dedicated label column area at x=0 in canvas coords, transformed to screen. Each label vertically centered within its row.
   - **Horizontal row separator lines:** Full-width dashed lines at each row boundary (top of each row + bottom of last row). Stroke: #d1d5db, strokeWidth: 1, strokeDasharray: "6 3".
   - **Column header labels:** Text elements at top of each column, horizontally centered within column width. Positioned above the grid area (at `config.origin.y - 15` in canvas coords). Font: 12px, weight 600, fill #6b7280.
   - **Vertical column separator lines:** Full-height dashed lines at each column boundary. Stroke: #e5e7eb, strokeWidth: 1, strokeDasharray: "4 4".
   - **Cell highlight:** When `highlightedCell` is provided, render a filled rectangle at the cell's bounds with fill="#dbeafe" (Tailwind blue-100) and opacity={0.4}. Use getCellBounds to calculate position, transform to screen coords.

4. **SVG container:** `className="absolute inset-0 pointer-events-none z-10"` with width="100%" height="100%" (matches QuadrantOverlay).

5. **Row labels should stay readable at all zoom levels.** Use a fixed font size (13px) - the SVG transforms handle the rest since we're computing screen coordinates from canvas coordinates.

**Key patterns from QuadrantOverlay to follow:**
- `'use client'` directive at top
- `useReactFlowStore(viewportSelector)` for reactive viewport
- Screen coordinate calculation: `canvasCoord * zoom + viewportOffset`
- `pointer-events-none` on SVG to avoid blocking post-it interaction

**Do NOT:**
- Use HTML div elements for grid lines (won't transform with zoom).
- Hardcode pixel positions (calculate dynamically from config).
- Scale font size with zoom (keep fixed for readability).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify: `grep "export function GridOverlay" src/components/canvas/grid-overlay.tsx` confirms export. Verify: `grep "highlightedCell" src/components/canvas/grid-overlay.tsx` confirms highlight support. Verify: `grep "pointer-events-none" src/components/canvas/grid-overlay.tsx` confirms non-blocking overlay.
  </verify>
  <done>
GridOverlay component renders viewport-aware SVG with 7 row labels, 5 column headers, grid lines (horizontal + vertical), and conditional cell highlighting in light blue. SVG is pointer-events-none and stays aligned during pan/zoom.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire grid into ReactFlowCanvas and add journey-map context assembly</name>
  <files>src/components/canvas/react-flow-canvas.tsx, src/lib/workshop/context/canvas-context.ts</files>
  <action>
**Part A: Wire grid into ReactFlowCanvas (react-flow-canvas.tsx)**

Add imports:
```typescript
import { GridOverlay } from './grid-overlay';
import { positionToCell, snapToCell } from '@/lib/canvas/grid-layout';
import type { CellCoordinate } from '@/lib/canvas/grid-layout';
```

Add state for cell highlighting:
```typescript
const [highlightedCell, setHighlightedCell] = useState<CellCoordinate | null>(null);
```

**Modify handleNodesChange** to add grid-specific snap and cell assignment:

When a position change completes (dragging === false) AND stepConfig.hasGrid is true:
1. Use `snapToCell(change.position, stepConfig.gridConfig)` instead of `snapToGrid(change.position)` for the position.
2. Use `positionToCell(snappedPosition, stepConfig.gridConfig)` to detect cell.
3. If cell detected, compute cellAssignment: `{ row: gridConfig.rows[cell.row].id, col: gridConfig.columns[cell.col].id }`.
4. Call `updatePostIt(change.id, { position: snappedPosition, cellAssignment })`.
5. Clear highlightedCell: `setHighlightedCell(null)`.

For non-grid steps, keep existing behavior (snapToGrid + quadrant detection).

**Add onNodeDrag handler** for real-time cell highlighting:

Create `handleNodeDrag` callback:
```typescript
const handleNodeDrag = useCallback(
  (_event: React.MouseEvent, node: Node) => {
    if (stepConfig.hasGrid && stepConfig.gridConfig) {
      const cell = positionToCell(node.position, stepConfig.gridConfig);
      setHighlightedCell(cell); // null if outside grid
    }
  },
  [stepConfig]
);
```

Add `onNodeDrag={handleNodeDrag}` to ReactFlow props. Note: ReactFlow calls onNodeDrag during drag (not just on stop). This provides real-time highlighting.

Also clear highlight on drag stop by adding to the existing drag-stop logic:
```typescript
setHighlightedCell(null);
```

**Modify createPostItAtPosition and handleToolbarAdd** for grid steps:

When `stepConfig.hasGrid && stepConfig.gridConfig`:
1. Use `snapToCell(position, stepConfig.gridConfig)` for the snapped position.
2. Compute cellAssignment from `positionToCell`.
3. Pass cellAssignment to addPostIt.
4. Do NOT detect quadrant (grid and quadrant are mutually exclusive).

**Modify handleInit** for grid steps:

For grid steps with 0 post-its, set initial viewport to show the grid origin area:
```typescript
if (stepConfig.hasGrid && postIts.length === 0) {
  instance.setViewport({
    x: 50,  // Small left margin
    y: 20,  // Small top margin
    zoom: 1,
  });
}
```

**Conditional rendering** inside ReactFlow JSX:

After the existing QuadrantOverlay conditional, add:
```tsx
{stepConfig.hasGrid && stepConfig.gridConfig && (
  <GridOverlay
    config={stepConfig.gridConfig}
    highlightedCell={highlightedCell}
  />
)}
```

**Part B: Add journey-map context assembly (canvas-context.ts)**

Add new function `assembleJourneyMapCanvasContext(postIts: PostIt[]): string`:
- Filter out group nodes.
- Group post-its by `cellAssignment.row` first, then by `cellAssignment.col`.
- For each row, list items grouped by column.
- Format:
```
**Actions:**
  Awareness: Item 1, Item 2
  Consideration: Item 3

**Goals:**
  Awareness: Item 4
  Decision: Item 5
```
- Post-its without cellAssignment go under "Unplaced" section at end.
- Return empty string if no items.

Update `assembleCanvasContextForStep` dispatcher:
- Add route for `stepId === 'journey-mapping'` that calls `assembleJourneyMapCanvasContext`.

**Do NOT:**
- Modify the existing quadrant detection logic paths (keep them intact for Steps 2 & 4).
- Use ReactFlow's snapToGrid prop for grid steps (use custom snap from grid-layout.ts).
- Create separate state management for grid (use existing canvas store).
- Break existing auto-save (cellAssignment serializes to JSONB automatically).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors. Run `npm run build` to confirm SSR safety. Verify: `grep "GridOverlay" src/components/canvas/react-flow-canvas.tsx` shows import and render. Verify: `grep "snapToCell" src/components/canvas/react-flow-canvas.tsx` shows custom snap usage. Verify: `grep "highlightedCell" src/components/canvas/react-flow-canvas.tsx` shows highlight state. Verify: `grep "journey-mapping" src/lib/workshop/context/canvas-context.ts` shows context assembly route. Verify: `grep "assembleJourneyMapCanvasContext" src/lib/workshop/context/canvas-context.ts` shows export.
  </verify>
  <done>
Step 6 canvas displays grid overlay with 7 swimlane rows and 5 columns. Post-its snap to cell boundaries on drag-stop. Cells highlight in light blue during drag. Cell assignment metadata stored alongside position. Journey-map AI context assembles grouped by row/column. Non-grid steps unaffected. Auto-save persists grid state. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds (SSR safety preserved)
3. Step 6 (journey-mapping) canvas renders GridOverlay with 7 rows and 5 columns
4. Steps 2 and 4 continue rendering QuadrantOverlay (no regression)
5. Steps without grid/quadrant render standard canvas (no regression)
6. GridOverlay SVG stays aligned during pan/zoom at all zoom levels
7. Cell highlights in light blue (#dbeafe) during node drag
8. Post-its snap to cell boundaries (with 10px padding) on drag stop
9. Post-its receive cellAssignment metadata on creation and drag
10. canvas-context.ts routes journey-mapping to row/column grouped assembly
11. Existing auto-save persists cellAssignment in JSONB without schema changes
12. No new npm dependencies added
</verification>

<success_criteria>
- User sees 7 fixed swimlane rows (Actions, Goals, Barriers, Touchpoints, Emotions, Moments of Truth, Opportunities) with labeled headers on Step 6 canvas
- Post-it items snap to cell boundaries when dragged and dropped
- Post-it items store cell assignment metadata (row + column) alongside pixel position
- Grid overlay stays aligned with canvas during pan and zoom
- Target cell highlights with light blue background during drag
- Grid canvas state persists to database via existing auto-save
- Non-grid steps function without regression
</success_criteria>

<output>
After completion, create `.planning/phases/21-grid-foundation-coordinate-system/21-02-SUMMARY.md`
</output>
