---
phase: 44-ai-deliverable-generation
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/build-pack/load-workshop-artifacts.ts
  - src/lib/ai/prompts/prd-generation.ts
  - src/lib/ai/prompts/tech-specs-generation.ts
  - src/app/api/build-pack/generate-prd/route.ts
  - src/app/api/build-pack/generate-tech-specs/route.ts
autonomous: true
requirements: [GEN-01, GEN-02, GEN-03, GEN-04]

must_haves:
  truths:
    - "After calling generate-prd API with a workshopId, a build_packs row exists with formatType='markdown' containing a PRD in Markdown"
    - "After calling generate-prd API with a workshopId, a build_packs row exists with formatType='json' containing a structured JSON PRD"
    - "After calling generate-tech-specs API with a workshopId, a build_packs row exists with formatType='markdown' containing Tech Specs in Markdown"
    - "After calling generate-tech-specs API with a workshopId, a build_packs row exists with formatType='json' containing structured JSON Tech Specs"
    - "Generation prompts reference data from all 10 workshop steps, not just a subset"
    - "Repeated calls return cached results without re-invoking Gemini"
  artifacts:
    - path: "src/lib/build-pack/load-workshop-artifacts.ts"
      provides: "Full 10-step artifact loading"
      contains: "stakeholder-mapping"
    - path: "src/lib/ai/prompts/prd-generation.ts"
      provides: "PRD generation prompt using all 10 step artifacts"
      contains: "buildFullPrdPrompt"
    - path: "src/lib/ai/prompts/tech-specs-generation.ts"
      provides: "Tech Specs generation prompt"
      contains: "buildTechSpecsPrompt"
    - path: "src/app/api/build-pack/generate-prd/route.ts"
      provides: "PRD generation API storing markdown + JSON"
      exports: ["POST"]
    - path: "src/app/api/build-pack/generate-tech-specs/route.ts"
      provides: "Tech Specs generation API storing markdown + JSON"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/build-pack/generate-prd/route.ts"
      to: "src/lib/build-pack/load-workshop-artifacts.ts"
      via: "loadAllWorkshopArtifacts call"
      pattern: "loadAllWorkshopArtifacts"
    - from: "src/app/api/build-pack/generate-prd/route.ts"
      to: "src/lib/ai/prompts/prd-generation.ts"
      via: "buildFullPrdPrompt call"
      pattern: "buildFullPrdPrompt"
    - from: "src/app/api/build-pack/generate-tech-specs/route.ts"
      to: "src/lib/ai/prompts/tech-specs-generation.ts"
      via: "buildTechSpecsPrompt call"
      pattern: "buildTechSpecsPrompt"
    - from: "src/app/api/build-pack/generate-prd/route.ts"
      to: "build_packs table"
      via: "db.insert(buildPacks) with markdown + json rows"
      pattern: "buildPacks.*insert"
---

<objective>
Build the AI generation engine that produces PRD and Tech Specs deliverables from all 10 workshop step artifacts, stored as both Markdown and structured JSON in the database.

Purpose: This is the core value of the Build Pack — turning 10 steps of workshop data into AI-coder-ready documents. Without this, the "Complete Workshop" button leads to a dead end.

Output: Two API routes that generate and cache PRD and Tech Specs documents, each stored as both Markdown text and structured JSON in the `build_packs` table.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-workshop-completion/43-01-SUMMARY.md
@.planning/phases/43-workshop-completion/43-02-SUMMARY.md

Key source files:
@src/lib/build-pack/load-workshop-artifacts.ts
@src/lib/ai/prompts/prd-generation.ts
@src/app/api/build-pack/generate-prd/route.ts
@src/lib/ai/gemini-retry.ts
@src/lib/ai/usage-tracking.ts
@src/db/schema/build-packs.ts
@src/lib/workshop/step-metadata.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand artifact loading to all 10 steps and create PRD + Tech Specs prompts</name>
  <files>
    src/lib/build-pack/load-workshop-artifacts.ts
    src/lib/ai/prompts/prd-generation.ts
    src/lib/ai/prompts/tech-specs-generation.ts
  </files>
  <action>
**1. Expand `load-workshop-artifacts.ts` to load all 10 steps:**

The current `WorkshopArtifacts` interface only covers 6 steps. Add a new `AllWorkshopArtifacts` interface covering all 10 steps and a new `loadAllWorkshopArtifacts(workshopId)` function. Keep the existing `WorkshopArtifacts` and `loadWorkshopArtifacts` unchanged (they're used by the existing V0 generate-prd route).

New interface:
```typescript
export interface AllWorkshopArtifacts {
  challenge: Record<string, unknown> | null;         // Step 1
  stakeholderMapping: Record<string, unknown> | null; // Step 2
  userResearch: Record<string, unknown> | null;       // Step 3
  senseMaking: Record<string, unknown> | null;        // Step 4
  persona: Record<string, unknown> | null;            // Step 5
  journeyMapping: Record<string, unknown> | null;     // Step 6
  reframe: Record<string, unknown> | null;            // Step 7
  ideation: Record<string, unknown> | null;           // Step 8
  concept: Record<string, unknown> | null;            // Step 9
  validate: Record<string, unknown> | null;           // Step 10
}
```

New STEP_ID_MAP for all 10:
```typescript
const ALL_STEP_ID_MAP: Record<string, keyof AllWorkshopArtifacts> = {
  'challenge': 'challenge',
  'stakeholder-mapping': 'stakeholderMapping',
  'user-research': 'userResearch',
  'sense-making': 'senseMaking',
  'persona': 'persona',
  'journey-mapping': 'journeyMapping',
  'reframe': 'reframe',
  'ideation': 'ideation',
  'concept': 'concept',
  'validate': 'validate',
};
```

The `loadAllWorkshopArtifacts` function follows the same DB query pattern as the existing one (innerJoin stepArtifacts with workshopSteps, filter by workshopId).

**2. Create `prd-generation.ts` — full PRD prompt:**

Add a new function `buildFullPrdPrompt(artifacts: AllWorkshopArtifacts): string` alongside the existing V0-prompt functions. Do NOT remove the existing `buildPrdGenerationPrompt` or `buildV0SystemPrompt` — those serve the V0 Prototype card.

The PRD prompt instructs Gemini to produce a comprehensive Product Requirements Document in Markdown format. The prompt should:
- Provide ALL 10 step artifacts as JSON context in `<workshop_data>` tags
- Instruct Gemini to produce a PRD with these sections:
  1. **Executive Summary** — derived from challenge statement (Step 1) + concept elevator pitch (Step 9)
  2. **Problem Statement** — from challenge (Step 1) + sense-making pain points (Step 4) + reframe HMW (Step 7)
  3. **Target Users** — from persona (Step 5) with demographics, goals, pains, behaviors
  4. **Stakeholder Analysis** — from stakeholder mapping (Step 2)
  5. **User Research Insights** — from user research (Step 3) + sense-making themes (Step 4)
  6. **User Journey** — from journey mapping (Step 6), include stages, actions, emotions, pain points, opportunities
  7. **Core Problem (HMW)** — from reframe (Step 7)
  8. **Solution Overview** — from concept (Step 9) including USP, elevator pitch, SWOT
  9. **Feature Requirements** — derived from ideation (Step 8) + concept (Step 9), with priority levels
  10. **Success Metrics** — derived from validation (Step 10) confidence assessment
  11. **Assumptions & Risks** — from challenge assumptions (Step 1) + concept SWOT threats (Step 9)
  12. **Recommended Next Steps** — from validation next steps (Step 10)
- Instruct Gemini to reference SPECIFIC workshop data (not generic boilerplate)
- Instruct Gemini to omit sections whose source step artifact is null
- Output ONLY the markdown, no preamble or meta-commentary
- Target 2000-3000 words for a comprehensive but readable document

Also add `buildFullPrdJsonPrompt(artifacts: AllWorkshopArtifacts): string` that instructs Gemini to produce the same PRD as structured JSON with this schema:
```json
{
  "title": "string",
  "executiveSummary": "string",
  "problemStatement": "string",
  "targetUsers": { "name": "string", "role": "string", "goals": ["string"], "pains": ["string"], "behaviors": ["string"] },
  "stakeholders": [{ "name": "string", "influence": "string", "interest": "string" }],
  "researchInsights": [{ "theme": "string", "evidence": "string" }],
  "userJourney": { "stages": [{ "name": "string", "actions": "string", "emotions": "string", "painPoints": "string", "opportunities": "string" }] },
  "hmwStatement": "string",
  "solution": { "name": "string", "usp": "string", "elevatorPitch": "string", "swot": { "strengths": ["string"], "weaknesses": ["string"], "opportunities": ["string"], "threats": ["string"] } },
  "features": [{ "name": "string", "description": "string", "priority": "must-have|should-have|nice-to-have", "userNeed": "string" }],
  "successMetrics": [{ "metric": "string", "target": "string" }],
  "assumptions": ["string"],
  "risks": ["string"],
  "nextSteps": ["string"]
}
```
Instruct Gemini to return ONLY valid JSON, no markdown fences or commentary.

**3. Create `tech-specs-generation.ts`:**

Create a new file with `buildTechSpecsPrompt(artifacts: AllWorkshopArtifacts): string` and `buildTechSpecsJsonPrompt(artifacts: AllWorkshopArtifacts): string`.

The Markdown prompt instructs Gemini to produce Technical Specifications derived from the workshop data:
  1. **System Overview** — architecture summary derived from concept (Step 9) + feature requirements
  2. **Technical Requirements** — functional requirements from features, non-functional from validation (Step 10)
  3. **Data Model** — entities and relationships derived from persona (Step 5), journey (Step 6), concept features
  4. **API Design** — key endpoints derived from features and user flows
  5. **User Interface Specifications** — screen/page requirements from journey stages (Step 6) + concept
  6. **Integration Requirements** — external services/APIs implied by the concept
  7. **Security & Privacy** — requirements derived from stakeholder analysis (Step 2) + user data in persona
  8. **Performance Requirements** — derived from user expectations in journey mapping
  9. **Testing Strategy** — high-level test areas based on features and user journey
  10. **Implementation Roadmap** — phased approach from recommended next steps (Step 10)
- Same rules: reference specific workshop data, omit sections with null source artifacts, output ONLY markdown
- Target 1500-2500 words

The JSON prompt produces structured output:
```json
{
  "title": "string",
  "systemOverview": "string",
  "requirements": { "functional": [{ "id": "string", "description": "string", "priority": "string" }], "nonFunctional": [{ "category": "string", "requirement": "string" }] },
  "dataModel": { "entities": [{ "name": "string", "fields": [{ "name": "string", "type": "string", "description": "string" }], "relationships": ["string"] }] },
  "apiDesign": { "endpoints": [{ "method": "string", "path": "string", "description": "string", "requestBody": "string", "responseBody": "string" }] },
  "uiSpecifications": { "screens": [{ "name": "string", "purpose": "string", "keyElements": ["string"] }] },
  "integrations": [{ "service": "string", "purpose": "string", "type": "string" }],
  "security": [{ "area": "string", "requirement": "string" }],
  "performance": [{ "metric": "string", "target": "string" }],
  "testingStrategy": { "areas": [{ "area": "string", "approach": "string" }] },
  "implementationRoadmap": { "phases": [{ "name": "string", "focus": "string", "deliverables": ["string"] }] }
}
```
  </action>
  <verify>
- `npx tsc --noEmit` passes (no TypeScript errors)
- `AllWorkshopArtifacts` interface has all 10 step keys
- `loadAllWorkshopArtifacts` function is exported
- `buildFullPrdPrompt`, `buildFullPrdJsonPrompt` are exported from prd-generation.ts
- `buildTechSpecsPrompt`, `buildTechSpecsJsonPrompt` are exported from tech-specs-generation.ts
  </verify>
  <done>
- `loadAllWorkshopArtifacts` returns typed object with all 10 step artifacts from DB
- PRD prompt references all 10 steps with specific section-to-step mappings
- Tech Specs prompt derives technical requirements from workshop data
- Both prompts have Markdown and JSON variants
- Existing V0 prompt functions remain unchanged and functional
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PRD and Tech Specs generation API routes with dual-format storage</name>
  <files>
    src/app/api/build-pack/generate-prd/route.ts
    src/app/api/build-pack/generate-tech-specs/route.ts
  </files>
  <action>
**1. Refactor `generate-prd/route.ts` to produce both Markdown and JSON PRD:**

The existing route generates a V0 prototype prompt. Preserve that functionality but ADD a new generation path for the full PRD. The route should differentiate based on a `type` field in the request body:
- `{ workshopId, type: 'v0' }` or `{ workshopId }` (no type) → existing V0 prototype behavior (backward compatible)
- `{ workshopId, type: 'full-prd' }` → new full PRD generation

For the `full-prd` path:
1. Check for existing cached build_packs rows: look for rows matching `workshopId` AND `title` LIKE `'PRD:%'` with both `formatType='markdown'` and `formatType='json'`. If both exist and have content, return cached result.
2. Load all artifacts via `loadAllWorkshopArtifacts(workshopId)`.
3. Generate Markdown PRD: call `generateTextWithRetry` with `google('gemini-2.0-flash')`, `temperature: 0.3` (lower for more consistent structured output), prompt from `buildFullPrdPrompt(artifacts)`.
4. Generate JSON PRD: call `generateTextWithRetry` with `google('gemini-2.0-flash')`, `temperature: 0.2`, prompt from `buildFullPrdJsonPrompt(artifacts)`. Parse the response text as JSON. If JSON.parse fails, wrap the raw text in `{ "raw": text }` as fallback.
5. Record usage events for both calls via `recordUsageEvent` (fire-and-forget), operation: `'generate-full-prd-md'` and `'generate-full-prd-json'`.
6. Store in `build_packs` table: upsert two rows:
   - `{ workshopId, title: 'PRD: <concept name or workshop title>', formatType: 'markdown', content: markdownText }`
   - `{ workshopId, title: 'PRD: <concept name or workshop title>', formatType: 'json', content: JSON.stringify(jsonResult) }`
   Use the concept name from `artifacts.concept?.name || artifacts.concept?.conceptName || 'Product'` for the title. For upsert: check if rows with matching workshopId + title prefix 'PRD:' + formatType exist, update if so, insert if not.
7. Return response: `{ markdown: markdownText, json: jsonResult, title: 'PRD: ...', cached: false }`.
8. Increase `maxDuration` to 60 (PRD generation uses more tokens than V0 prompt).

**2. Create `generate-tech-specs/route.ts`:**

Follow the same pattern as the PRD route but for Tech Specs:
1. `maxDuration = 60`
2. Accept `{ workshopId }` in POST body.
3. Check cache: look for `build_packs` rows with `workshopId` AND `title` LIKE `'Tech Specs:%'` in both markdown and json formats.
4. Load all artifacts via `loadAllWorkshopArtifacts`.
5. Generate Markdown via `buildTechSpecsPrompt(artifacts)`, temperature 0.3.
6. Generate JSON via `buildTechSpecsJsonPrompt(artifacts)`, temperature 0.2. Parse with JSON.parse fallback.
7. Record usage: operation `'generate-tech-specs-md'` and `'generate-tech-specs-json'`.
8. Store two rows in `build_packs`: `title: 'Tech Specs: <concept name>'`, one markdown, one json.
9. Return `{ markdown, json, title, cached: false }`.

**Auth note:** Both routes should verify the user owns the workshop. Use `auth()` from `@clerk/nextjs/server` to get userId, then verify `workshops.clerkUserId = userId` before proceeding. Return 401 if not authenticated, 403 if not the owner.

**Error handling:** Wrap Gemini calls in try/catch. If generation fails, return 500 with `{ error: 'Failed to generate...' }`. Do not let one format failure prevent the other — if markdown succeeds but JSON fails, store what succeeded and note the failure in the response.

**Parallel generation:** For efficiency, run the Markdown and JSON Gemini calls in parallel using `Promise.allSettled`. This halves the generation time.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- Both API route files export POST handlers
- `curl -X POST /api/build-pack/generate-prd -d '{"workshopId":"test","type":"full-prd"}' -H 'Content-Type: application/json'` would invoke the new path (test in browser or via dev tools after workshop completion)
- Existing V0 generation still works when called without `type` field
  </verify>
  <done>
- POST `/api/build-pack/generate-prd` with `type: 'full-prd'` generates and stores PRD as both Markdown and JSON
- POST `/api/build-pack/generate-tech-specs` generates and stores Tech Specs as both Markdown and JSON
- Both routes cache results — subsequent calls return stored content without re-invoking Gemini
- Both routes use auth + ownership verification
- Both routes record AI usage events
- Existing V0 prototype generation remains backward compatible
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes with no errors
2. `AllWorkshopArtifacts` covers all 10 steps by semantic ID
3. Both API routes exist and export POST handlers
4. Existing V0 generate-prd behavior is preserved (no type field = V0 path)
5. Build succeeds: `npm run build` completes without errors
</verification>

<success_criteria>
- All 10 workshop step artifacts are loaded and passed to generation prompts
- PRD document covers all design thinking steps in structured sections
- Tech Specs document derives technical requirements from workshop decisions
- Both deliverables stored as Markdown text AND structured JSON in build_packs table
- Caching prevents redundant Gemini calls on repeated requests
- Auth and ownership verified before generation
</success_criteria>

<output>
After completion, create `.planning/phases/44-ai-deliverable-generation/44-01-SUMMARY.md`
</output>
