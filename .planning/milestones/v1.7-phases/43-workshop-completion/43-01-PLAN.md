---
phase: 43-workshop-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/actions/workshop-actions.ts
  - src/app/api/workshops/[workshopId]/complete/route.ts
autonomous: true
requirements:
  - COMP-03

must_haves:
  truths:
    - "Calling completeWorkshop(workshopId) sets workshops.status to 'completed' in the database"
    - "Workshop completion persists across page refresh — querying the workshop returns status='completed'"
    - "Only the workshop owner can complete their workshop (auth check)"
    - "Completing an already-completed workshop is a no-op (idempotent)"
  artifacts:
    - path: "src/actions/workshop-actions.ts"
      provides: "completeWorkshop server action"
      contains: "completeWorkshop"
    - path: "src/app/api/workshops/[workshopId]/complete/route.ts"
      provides: "POST endpoint for workshop completion"
      exports: ["POST"]
  key_links:
    - from: "src/actions/workshop-actions.ts"
      to: "src/db/schema/workshops.ts"
      via: "drizzle update query"
      pattern: "workshops.*status.*completed"
---

<objective>
Add the server-side capability to mark a workshop as "completed" at the workshop level (not just the step level). This creates the persistent database state that Phase 44 will use as the trigger for deliverable generation.

Purpose: COMP-03 requires workshop completion status to persist in the database. The workshops table already has a `status` column with a `'completed'` enum value, but nothing currently sets it. This plan adds the server action and API endpoint.

Output: `completeWorkshop` server action and POST `/api/workshops/[workshopId]/complete` endpoint.
</objective>

<execution_context>
@/Users/michaelchristie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelchristie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/actions/workshop-actions.ts
@src/db/schema/workshops.ts
@src/db/schema/steps.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add completeWorkshop server action</name>
  <files>src/actions/workshop-actions.ts</files>
  <action>
Add a new exported server action `completeWorkshop` to the existing workshop-actions.ts file. Follow the established patterns in that file (auth via `getUserId()`, drizzle queries, revalidatePath).

The action should:
1. Accept `workshopId: string` and `sessionId: string` parameters
2. Authenticate the user via `getUserId()` — throw if not authenticated
3. Verify the workshop belongs to the current user (defense in depth, same pattern as `deleteWorkshops`)
4. Verify all 10 workshop steps have status='complete' by querying workshopSteps where workshopId matches and checking every step has completedAt set. If not all steps are complete, throw an error "All steps must be completed before finishing the workshop"
5. Update `workshops.status` to `'completed'` where `workshops.id = workshopId` AND `workshops.clerkUserId = userId`
6. Call `revalidatePath('/dashboard')` and `revalidatePath(`/workshop/${sessionId}`)` to refresh both views
7. Return `{ success: true }` on success

Make this idempotent: if workshop.status is already 'completed', return success without re-updating.

Do NOT use redirect() in this action — the calling component needs to handle UI state after completion.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Grep for `completeWorkshop` in workshop-actions.ts to confirm the export exists.
  </verify>
  <done>
`completeWorkshop` server action exported from workshop-actions.ts. Accepts workshopId + sessionId, verifies auth + ownership + all steps complete, sets workshop status to 'completed', revalidates paths. Idempotent.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add POST /api/workshops/[workshopId]/complete endpoint</name>
  <files>src/app/api/workshops/[workshopId]/complete/route.ts</files>
  <action>
Create a new API route at `src/app/api/workshops/[workshopId]/complete/route.ts`. Follow the pattern of the existing `src/app/api/workshops/[workshopId]/steps/[stepId]/complete/route.ts` endpoint.

The endpoint should:
1. Export a `POST` handler accepting `{ params: Promise<{ workshopId: string }> }` (Next.js 16 async params pattern)
2. Parse request body for `{ sessionId: string }` — return 400 if missing
3. Call the `completeWorkshop` server action from `@/actions/workshop-actions`
4. Return 200 with `{ success: true, status: 'completed' }` on success
5. Return 400 for validation errors (not all steps complete)
6. Return 401 for auth errors
7. Return 500 for unexpected errors
8. Wrap in try/catch with appropriate error logging (same pattern as step complete route)

This API route exists as a REST-accessible alternative to the server action, following the established pattern in the codebase.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Verify file exists at the correct path with `ls src/app/api/workshops/\[workshopId\]/complete/route.ts`.
  </verify>
  <done>
POST `/api/workshops/[workshopId]/complete` endpoint exists, calls completeWorkshop server action, returns appropriate status codes for success/failure.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `completeWorkshop` is exported from `src/actions/workshop-actions.ts`
3. POST route file exists at `src/app/api/workshops/[workshopId]/complete/route.ts`
4. The server action checks auth, ownership, and all-steps-complete before setting status
</verification>

<success_criteria>
- Workshop status can be programmatically set to 'completed' via server action or API
- Auth and ownership checks prevent unauthorized completion
- All 10 steps must be complete before workshop can be completed
- Idempotent: completing an already-completed workshop succeeds without error
- Dashboard and workshop paths are revalidated after completion
</success_criteria>

<output>
After completion, create `.planning/phases/43-workshop-completion/43-01-SUMMARY.md`
</output>
